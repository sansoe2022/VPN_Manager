#!/bin/bash
#====================================================
#	@kiritosshxd - Ubuntu 22.04 Compatible Version
#====================================================
cor1='\033[41;1;37m'
cor2='\033[44;1;37m'
scor='\033[0m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
SCOLOR='\033[0m'

[[ $(awk -F" " '{print $2}' /usr/lib/licence 2>/dev/null) == "@KIRITO_SSH" ]] && {
	ram1=$(free -h | grep -i mem | awk {'print $2'})
	ram2=$(free -h | grep -i mem | awk {'print $4'})
	ram3=$(free -h | grep -i mem | awk {'print $3'})
	uso=$(top -bn1 | awk '/Cpu/ { cpu = "" 100 - $8 "%" }; END { print cpu }')
	system=$(cat /etc/issue.net)
	
	fun_bar() {
		comando[0]="$1"
		comando[1]="$2"
		(
			[[ -e $HOME/fim ]] && rm $HOME/fim
			[[ ! -d /etc/SSHPlus ]] && rm -rf /bin/menu
			${comando[0]} >/dev/null 2>&1
			${comando[1]} >/dev/null 2>&1
			touch $HOME/fim
		) >/dev/null 2>&1 &
		tput civis
		echo -ne "\033[1;33mAGUARDE \033[1;37m- \033[1;33m["
		while true; do
			for ((i = 0; i < 18; i++)); do
				echo -ne "\033[1;31m#"
				sleep 0.1s
			done
			[[ -e $HOME/fim ]] && rm $HOME/fim && break
			echo -e "\033[1;33m]"
			sleep 1s
			tput cuu1
			tput dl1
			echo -ne "\033[1;33mAGUARDE \033[1;37m- \033[1;33m["
		done
		echo -e "\033[1;33m]\033[1;37m -\033[1;32m OK !\033[1;37m"
		tput cnorm
	}

	verif_ptrs() {
		porta=$1
		PT=$(ss -tlpn 2>/dev/null | grep -v "State")
		[[ -z "$PT" ]] && PT=$(lsof -V -i tcp -P -n 2>/dev/null | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
		
		for pton in $(echo -e "$PT" | awk '{print $5}' | cut -d: -f2 | sort -u 2>/dev/null); do
			[[ -z "$pton" ]] && continue
			svcs=$(echo -e "$PT" | grep ":$pton" | awk '{print $1}' | sort -u | head -1)
			[[ "$porta" = "$pton" ]] && {
				echo -e "\n\033[1;31mPORTA \033[1;33m$porta \033[1;31mEM USO PELO \033[1;37m$svcs\033[0m"
				sleep 3
				fun_conexao
			}
		done
	}

	slow_setup() {
		[[ -e "/bin/slowdns" ]] && {
			slowdns
		} || {
			cd $HOME
			wget https://raw.githubusercontent.com/kiritosshxd/SSHPLUS/main/Slowdns/install -O install 2>/dev/null
			chmod 777 install
			./install
		}
	}

inst_sqd() {
		if systemctl is-active --quiet squid 2>/dev/null || systemctl is-active --quiet squid3 2>/dev/null; then
			echo -e "\E[41;1;37m            REMOVER SQUID PROXY              \E[0m"
			echo ""
			echo -ne "\033[1;32mREALMENTE DESEJA REMOVER O SQUID \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resp
			[[ "$resp" = 's' ]] && {
				echo -e "\n\033[1;32mREMOVENDO O SQUID PROXY !\033[0m"
				echo ""
				rem_sqd() {
					systemctl stop squid 2>/dev/null
					systemctl stop squid3 2>/dev/null
					systemctl disable squid 2>/dev/null
					systemctl disable squid3 2>/dev/null
					apt-get remove squid squid3 -y >/dev/null 2>&1
					apt-get purge squid squid3 -y >/dev/null 2>&1
					rm -rf /etc/squid /etc/squid3 >/dev/null 2>&1
					apt autoremove -y >/dev/null 2>&1
				}
				fun_bar 'rem_sqd'
				echo -e "\n\033[1;32mSQUID REMOVIDO COM SUCESSO !\033[0m"
				sleep 2
				clear
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando...\033[0m"
				sleep 2
				clear
				fun_conexao
			}
		else
			clear
			echo -e "\E[44;1;37m              INSTALADOR SQUID                \E[0m"
			echo ""
			IP=$(wget -qO- ipv4.icanhazip.com 2>/dev/null)
			echo -ne "\033[1;32mPARA CONTINUAR CONFIRME SEU IP: \033[1;37m"
			read -e -i $IP ipdovps
			[[ -z "$ipdovps" ]] && {
				echo -e "\n\033[1;31mIP invalido\033[1;32m"
				echo ""
				read -p "Digite seu IP: " IP
			}
			echo -e "\n\033[1;33mQUAIS PORTAS DESEJA ULTILIZAR NO SQUID \033[1;31m?"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mDEFINA AS PORTAS EM SEQUENCIA \033[1;33mEX: \033[1;37m80 8080"
			echo ""
			echo -ne "\033[1;32mINFORME AS PORTAS\033[1;37m: "
			read portass
			[[ -z "$portass" ]] && {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 3
				fun_conexao
			}
			for porta in $(echo -e $portass); do
				verif_ptrs $porta
			done
			
			echo -e "\n\033[1;32mINSTALANDO SQUID PROXY\033[0m\n"
			fun_bar 'apt update -y' "apt install squid -y"
			
			if [[ -d "/etc/squid/" ]]; then
				var_sqd="/etc/squid/squid.conf"
				var_pay="/etc/squid/payload.txt"
			else
				echo -e "\n\033[1;33m[\033[1;31mERRO\033[1;33m]\033[1;37m: \033[1;33mO SQUID PROXY CORROMPEU\033[0m"
				sleep 2
				fun_conexao
			fi
			
			cat <<-EOF >$var_pay
				.whatsapp.net/
				.facebook.net/
				.twitter.com/
				.speedtest.net/
			EOF
			
			cat <<-EOF >$var_sqd
				acl url1 dstdomain -i 127.0.0.1
				acl url2 dstdomain -i localhost
				acl url3 dstdomain -i $ipdovps
				acl url4 dstdomain -i /SSHPLUS?
				acl payload url_regex -i "$var_pay"
				acl all src 0.0.0.0/0

				http_access allow url1
				http_access allow url2
				http_access allow url3
				http_access allow url4
				http_access allow payload
				http_access deny all
				 
				#Portas
			EOF
			
			for Pts in $(echo -e $portass); do
				echo -e "http_port $Pts" >>$var_sqd
				[[ -f "/usr/sbin/ufw" ]] && ufw allow $Pts/tcp 2>/dev/null
			done
			
			cat <<-EOF >>$var_sqd
				#Nome squid
				visible_hostname SSHPLUS 
				via off
				forwarded_for off
				pipeline_prefetch off
			EOF
			
			sqd_conf() {
				systemctl restart ssh
				systemctl restart squid
				systemctl enable squid
			}
			echo -e "\n\033[1;32mCONFIGURANDO SQUID PROXY\033[0m"
			echo ""
			fun_bar 'sqd_conf'
			echo -e "\n\033[1;32mSQUID INSTALADO COM SUCESSO!\033[0m"
			sleep 2.5s
			fun_conexao
		fi
	}

	fun_squid() {
		[[ ! $(systemctl is-active --quiet squid 2>/dev/null) ]] && inst_sqd
		echo -e "\E[44;1;37m          GERENCIAR SQUID PROXY           \E[0m"
		if systemctl is-active --quiet squid 2>/dev/null; then
			sqdp=$(ss -tlpn 2>/dev/null | grep 'squid' | awk '{print $4}' | cut -d: -f2 | xargs)
			echo -e "\n\033[1;33mPORTAS\033[1;37m: \033[1;32m$sqdp"
			VarSqdOn="REMOVER SQUID PROXY"
		else
			VarSqdOn="INSTALAR SQUID PROXY"
		fi
		echo -e "\n\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33m$VarSqdOn \033[1;31m
[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mADICIONAR PORTA \033[1;31m
[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mREMOVER PORTA\033[1;31m
[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
		echo ""
		echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;31m?\033[1;37m "
		read x
		clear
		case $x in
		1 | 01) inst_sqd ;;
		0 | 00) echo -e "\033[1;31mRetornando...\033[0m"; sleep 1; fun_conexao ;;
		*) echo -e "\033[1;31mOpcao Invalida...\033[0m"; sleep 2; fun_conexao ;;
		esac
	}

	fun_drop() {
		if systemctl is-active --quiet dropbear 2>/dev/null; then
			clear
			dpbr=$(ss -tlpn 2>/dev/null | grep 'dropbear' | awk '{print $4}' | cut -d: -f2 | xargs)
			[[ -z "$dpbr" ]] && dpbr="\033[1;31mINDISPONIVEL"
			echo -e "\E[44;1;37m              GERENCIAR DROPBEAR               \E[0m"
			echo -e "\n\033[1;33mPORTAS\033[1;37m: \033[1;32m$dpbr"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA DROPBEAR\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER DROPBEAR\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
			echo ""
			echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
			read resposta
			if [[ "$resposta" = '1' ]]; then
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m "
				read pt
				echo ""
				verif_ptrs $pt
				var1=$(grep 'DROPBEAR_PORT=' /etc/default/dropbear 2>/dev/null | cut -d'=' -f2)
				echo -e "\033[1;32mALTERANDO PORTA DROPBEAR!"
				sed -i "s/\b$var1\b/$pt/g" /etc/default/dropbear >/dev/null 2>&1
				echo ""
				fun_bar 'sleep 2'
				echo -e "\n\033[1;32mREINICIANDO DROPBEAR!"
				echo ""
				fun_bar 'systemctl restart dropbear'
				echo -e "\n\033[1;32mPORTA ALTERADA COM SUCESSO!"
				sleep 3
				clear
				fun_conexao
			elif [[ "$resposta" = '2' ]]; then
				echo -e "\n\033[1;32mREMOVENDO O DROPBEAR !\033[0m"
				echo ""
				fun_dropunistall() {
					systemctl stop dropbear
					systemctl disable dropbear
					apt-get autoremove dropbear -y
					apt-get remove dropbear -y
					apt-get purge dropbear -y
					rm -rf /etc/default/dropbear
				}
				fun_bar 'fun_dropunistall'
				echo -e "\n\033[1;32mDROPBEAR REMOVIDO COM SUCESSO !\033[0m"
				sleep 3
				clear
				fun_conexao
			elif [[ "$resposta" = '0' ]]; then
				echo -e "\n\033[1;31mRetornando...\033[0m"
				sleep 2
				fun_conexao
			else
				echo -e "\n\033[1;31mOpcao invalida...\033[0m"
				sleep 2
				fun_conexao
			fi
		else
			clear
			echo -e "\E[44;1;37m           INSTALADOR DROPBEAR              \E[0m"
			echo -e "\n\033[1;33mVC ESTA PRESTES A INSTALAR O DROPBEAR !\033[0m\n"
			echo -ne "\033[1;32mDESEJA CONTINUAR \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resposta
			[[ "$resposta" = 's' ]] && {
				echo -e "\n\033[1;33mDEFINA UMA PORTA PARA O DROPBEAR !\033[0m\n"
				echo -ne "\033[1;32mQUAL A PORTA \033[1;33m?\033[1;37m "
				read porta
				[[ -z "$porta" ]] && {
					echo -e "\n\033[1;31mPorta invalida!"
					sleep 3
					clear
					fun_conexao
				}
				verif_ptrs $porta
				echo -e "\n\033[1;32mINSTALANDO O DROPBEAR ! \033[0m"
				echo ""
				fun_instdrop() {
					apt-get update -y
					apt-get install dropbear -y
				}
				fun_bar 'fun_instdrop'
				fun_ports() {
					sed -i 's/NO_START=1/NO_START=0/g' /etc/default/dropbear >/dev/null 2>&1
					sed -i "s/DROPBEAR_PORT=22/DROPBEAR_PORT=$porta/g" /etc/default/dropbear >/dev/null 2>&1
					sed -i 's/DROPBEAR_EXTRA_ARGS=/DROPBEAR_EXTRA_ARGS="-p 110"/g' /etc/default/dropbear >/dev/null 2>&1
				}
				echo ""
				echo -e "\033[1;32mCONFIGURANDO PORTA DROPBEAR !\033[0m"
				echo ""
				fun_bar 'fun_ports'
				grep -v "^PasswordAuthentication yes" /etc/ssh/sshd_config >/tmp/passlogin && mv /tmp/passlogin /etc/ssh/sshd_config
				echo "PasswordAuthentication yes" >>/etc/ssh/sshd_config
				grep -v "^PermitTunnel yes" /etc/ssh/sshd_config >/tmp/ssh && mv /tmp/ssh /etc/ssh/sshd_config
				echo "PermitTunnel yes" >>/etc/ssh/sshd_config
				echo ""
				echo -e "\033[1;32mFINALIZANDO INSTALACAO !\033[0m"
				echo ""
				fun_ondrop() {
					systemctl start dropbear
					systemctl enable dropbear
					systemctl restart dropbear
				}
				fun_bar 'fun_ondrop' 'sleep 1'
				echo -e "\n\033[1;32mINSTALACAO CONCLUIDA \033[1;33mPORTA: \033[1;37m$porta\033[0m"
				[[ $(grep -c "/bin/false" /etc/shells) = '0' ]] && echo "/bin/false" >>/etc/shells
				sleep 2
				clear
				fun_conexao
			} || {
				echo""
				echo -e "\033[1;31mRetornando...\033[0m"
				sleep 3
				clear
				fun_conexao
			}
		fi
	}

	inst_ssl() {
		if systemctl is-active --quiet stunnel4 2>/dev/null; then
			sslt=$(ss -tlpn 2>/dev/null | grep 'stunnel' | awk '{print $4}' | cut -d: -f2 | xargs)
			[[ -z "$sslt" ]] && sslt="\033[1;31mINDISPONIVEL"
			echo -e "\E[44;1;37m              GERENCIAR SSL TUNNEL               \E[0m"
			echo -e "\n\033[1;33mPORTAS\033[1;37m: \033[1;32m$sslt"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA SSL TUNNEL\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER SSL TUNNEL\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
			echo ""
			echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
			read resposta
			echo ""
			[[ "$resposta" = '1' ]] && {
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m "
				read porta
				echo ""
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 2
					clear
					fun_conexao
				}
				verif_ptrs $porta
				echo -e "\033[1;32mALTERANDO PORTA SSL TUNNEL!"
				var2=$(grep 'accept' /etc/stunnel/stunnel.conf | awk '{print $NF}')
				sed -i "s/\b$var2\b/$porta/g" /etc/stunnel/stunnel.conf >/dev/null 2>&1
				echo ""
				fun_bar 'sleep 2'
				echo ""
				echo -e "\033[1;32mREINICIANDO SSL TUNNEL!\n"
				fun_bar 'systemctl restart stunnel4'
				echo ""
				systemctl is-active --quiet stunnel4 && echo -e "\033[1;32mPORTA ALTERADA COM SUCESSO !" || echo -e "\033[1;31mERRO INESPERADO!"
				sleep 3.5s
				clear
				fun_conexao
			}
			[[ "$resposta" = '2' ]] && {
				echo -e "\033[1;32mREMOVENDO O  SSL TUNNEL !\033[0m"
				del_ssl() {
					systemctl stop stunnel4
					systemctl disable stunnel4
					apt-get remove stunnel4 -y
					apt-get autoremove stunnel4 -y
					apt-get purge stunnel4 -y
					rm -rf /etc/stunnel/stunnel.conf
					rm -rf /etc/default/stunnel4
					rm -rf /etc/stunnel/cert.cert
					rm -rf /etc/stunnel/key.key
				}
				echo ""
				fun_bar 'del_ssl'
				echo ""
				echo -e "\033[1;32mSSL TUNNEL REMOVIDO COM SUCESSO!\033[0m"
				sleep 3
				fun_conexao
			}
		else
			clear
			echo -e "\E[44;1;37m              INSTALAR SSL TUNNEL               \E[0m"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mINSTALAR SSL TUNNEL PADRÃO\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mINSTALAR SSL TUNNEL WEBSOCKET\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
			echo ""
			echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
			read resposta
			echo ""
			if [[ "$resposta" = '1' ]]; then
				portssl='22'
			elif [[ "$resposta" = '2' ]]; then
				portssl='80'
			elif [[ "$resposta" = '0' ]]; then
				echo -e "\033[1;31mRetornando...\033[0m"
				sleep 3
				fun_conexao
			else
				echo ""
				echo -e "\033[1;31mOpcao invalida !\033[0m"
				sleep 1
				inst_ssl
			fi
			clear
			echo -e "\E[44;1;37m           INSTALADOR SSL TUNNEL             \E[0m"
			echo -e "\n\033[1;33mVC ESTA PRESTES A INSTALAR O SSL TUNNEL !\033[0m"
			echo ""
			echo -ne "\033[1;32mDESEJA CONTINUAR \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resposta
			[[ "$resposta" = 's' ]] && {
				echo -e "\n\033[1;33mDEFINA UMA PORTA PARA O SSL TUNNEL !\033[0m"
				echo ""
				read -p "$(echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR? \033[1;37m")" -e -i 443 porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 3
					clear
					fun_conexao
				}
				verif_ptrs $porta
				echo -e "\n\033[1;32mINSTALANDO O SSL TUNNEL !\033[1;33m"
				echo ""
				fun_bar 'apt-get update -y' 'apt-get install stunnel4 -y'
				echo -e "\n\033[1;32mCONFIGURANDO O SSL TUNNEL !\033[0m"
				echo ""
				ssl_conf() {
					echo -e "cert = /etc/stunnel/stunnel.pem\nclient = no\nsocket = a:SO_REUSEADDR=1\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n\n[stunnel]\nconnect = 127.0.0.1:${portssl}\naccept = ${porta}" >/etc/stunnel/stunnel.conf
				}
				fun_bar 'ssl_conf'
				echo -e "\n\033[1;32mCRIANDO CERTIFICADO !\033[0m"
				echo ""
				ssl_certif() {
					crt='EC'
					openssl genrsa -out key.pem 2048 >/dev/null 2>&1
					(
						echo $crt
						echo $crt
						echo $crt
						echo $crt
						echo $crt
						echo $crt
						echo $crt
					) | openssl req -new -x509 -key key.pem -out cert.pem -days 1050 >/dev/null 2>&1
					cat cert.pem key.pem >>/etc/stunnel/stunnel.pem
					rm key.pem cert.pem >/dev/null 2>&1
					sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
				}
				fun_bar 'ssl_certif'
				echo -e "\n\033[1;32mINICIANDO O SSL TUNNEL !\033[0m"
				echo ""
				fun_finssl() {
					systemctl restart stunnel4
					systemctl enable stunnel4
					systemctl restart ssh
				}
				fun_bar 'fun_finssl'
				echo -e "\n\033[1;32mSSL TUNNEL INSTALADO COM SUCESSO !\033[1;31m PORTA: \033[1;33m$porta\033[0m"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando...\033[0m"
				sleep 2
				clear
				fun_conexao
			}
		fi
	}

	fun_openssh() {
		clear
		echo -e "\E[44;1;37m            OPENSSH             \E[0m\n"
		echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mADICIONAR PORTA\033[1;31m
[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER PORTA\033[1;31m
[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
		echo ""
		echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
		read resp
		if [[ "$resp" = '1' ]]; then
			clear
			echo -e "\E[44;1;37m         ADICIONAR PORTA AO SSH         \E[0m\n"
			echo -ne "\033[1;32mQUAL PORTA DESEJA ADICIONAR \033[1;33m?\033[1;37m "
			read pt
			[[ -z "$pt" ]] && {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 3
				fun_conexao
			}
			verif_ptrs $pt
			echo -e "\n\033[1;32mADICIONANDO PORTA AO SSH\033[0m"
			echo ""
			fun_addpssh() {
				echo "Port $pt" >>/etc/ssh/sshd_config
				systemctl restart ssh
			}
			fun_bar 'fun_addpssh'
			echo -e "\n\033[1;32mPORTA ADICIONADA COM SUCESSO\033[0m"
			sleep 3
			fun_conexao
		elif [[ "$resp" = '2' ]]; then
			clear
			echo -e "\E[41;1;37m         REMOVER PORTA DO SSH         \E[0m"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mPORTA PADRAO \033[1;37m22 \033[1;33mCUIDADO !\033[0m"
			echo -e "\n\033[1;33mPORTAS EM USO: \033[1;37m$(grep 'Port' /etc/ssh/sshd_config | cut -d' ' -f2 | grep -v 'no' | xargs)\n"
			echo -ne "\033[1;32mQUAL PORTA DESEJA REMOVER \033[1;33m?\033[1;37m "
			read pt
			[[ -z "$pt" ]] && {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 2
				fun_conexao
			}
			[[ $(grep -wc "$pt" '/etc/ssh/sshd_config') != '0' ]] && {
				echo -e "\n\033[1;32mREMOVENDO PORTA DO SSH\033[0m"
				echo ""
				fun_delpssh() {
					sed -i "/Port $pt/d" /etc/ssh/sshd_config
					systemctl restart ssh
				}
				fun_bar 'fun_delpssh'
				echo -e "\n\033[1;32mPORTA REMOVIDA COM SUCESSO\033[0m"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mPorta invalida!"
				sleep 2
				fun_conexao
			}
		elif [[ "$resp" = '3' ]]; then
			echo -e "\n\033[1;31mRetornando.."
			sleep 2
			fun_conexao
		else
			echo -e "\n\033[1;31mOpcao invalida!"
			sleep 2
			fun_conexao
		fi
	}

	fun_sslh() {
		if ! ss -tlpn 2>/dev/null | grep 'sslh' 1>/dev/null 2>/dev/null; then
			clear
			echo -e "\E[44;1;37m             INSTALADOR SSLH               \E[0m\n"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mA PORTA \033[1;37m443 \033[1;32mSERA USADA POR PADRAO\033[0m\n"
			echo -ne "\033[1;32mREALMENTE DESEJA INSTALAR O SSLH \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resp
			[[ "$resp" = 's' ]] && {
				verif_ptrs 443
				fun_instsslh() {
					[[ -e "/etc/stunnel/stunnel.conf" ]] && ptssl="$(ss -tlpn 2>/dev/null | grep 'stunnel' | awk '{print $4}' | cut -d: -f2 | xargs)" || ptssl='3128'
					[[ -e "/etc/openvpn/server.conf" ]] && ptvpn="$(ss -tlpn 2>/dev/null | grep 'openvpn' | awk '{print $4}' | cut -d: -f2 | xargs)" || ptvpn='1194'
					DEBIAN_FRONTEND=noninteractive apt-get -y install sslh
					echo -e "#Modo autónomo\n\nRUN=yes\n\nDAEMON=/usr/sbin/sslh\n\nDAEMON_OPTS='--user sslh --listen 0.0.0.0:443 --ssh 127.0.0.1:22 --ssl 127.0.0.1:$ptssl --http 127.0.0.1:80 --openvpn 127.0.0.1:$ptvpn --pidfile /var/run/sslh/sslh.pid'" >/etc/default/sslh
					systemctl start sslh
					systemctl enable sslh
				}
				echo -e "\n\033[1;32mINSTALANDO O SSLH !\033[0m\n"
				fun_bar 'fun_instsslh'
				echo -e "\n\033[1;32mINICIANDO O SSLH !\033[0m\n"
				fun_bar 'systemctl restart sslh'
				[[ $(ss -tlpn 2>/dev/null | grep -wc 'sslh') != '0' ]] && echo -e "\n\033[1;32mINSTALADO COM SUCESSO !\033[0m" || echo -e "\n\033[1;31mERRO INESPERADO !\033[0m"
				sleep 3
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando.."
				sleep 2
				fun_conexao
			}
		else
			clear
			echo -e "\E[41;1;37m             REMOVER O SSLH               \E[0m\n"
			echo -ne "\033[1;32mREALMENTE DESEJA REMOVER O SSLH \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read respo
			[[ "$respo" = "s" ]] && {
				fun_delsslh() {
					systemctl stop sslh
					systemctl disable sslh
					apt-get remove sslh -y
					apt-get purge sslh -y
				}
				echo -e "\n\033[1;32mREMOVENDO O SSLH !\033[0m\n"
				fun_bar 'fun_delsslh'
				echo -e "\n\033[1;32mREMOVIDO COM SUCESSO !\033[0m\n"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mRetornando.."
				sleep 2
				fun_conexao
			}
		fi
	}






            
# Replace only the fun_openvpn() function in your Modulos/conexao script with the following improved version.

fun_openvpn() {
    # Ensure running with bash (not dash/sh)
    if readlink /proc/$$/exe | grep -qs "dash"; then
        echo "Este script precisa ser executado com bash, não sh"
        exit 1
    fi

    [[ "$EUID" -ne 0 ]] && {
        clear
        echo "Execute como root"
        exit 2
    }

    [[ ! -e /dev/net/tun ]] && {
        echo -e "\033[1;31mTUN TAP NAO DISPONIVEL\033[0m"
        sleep 2
        exit 3
    }

    RCLOCAL="/etc/rc.local"

    # ensure a sane /etc/rc.local exists (so other parts can append to it safely)
    if [[ ! -f "$RCLOCAL" ]]; then
        cat >"$RCLOCAL" <<'EOF'
#!/bin/sh -e
# rc.local compatibility file created by script
exit 0
EOF
        chmod +x "$RCLOCAL" 2>/dev/null || true
    fi

    newclient() {
        # gerar client.ovpn
        local name="$1"
        cp -f /etc/openvpn/client-common.txt ~/"$name".ovpn
        {
            echo "<ca>"
            cat /etc/openvpn/ca.crt
            echo "</ca>"
            echo "<cert>"
            cat /etc/openvpn/easy-rsa/pki/issued/"$name".crt
            echo "</cert>"
            echo "<key>"
            cat /etc/openvpn/easy-rsa/pki/private/"$name".key
            echo "</key>"
            echo "<tls-auth>"
            cat /etc/openvpn/ta.key
            echo "</tls-auth>"
        } >> ~/"$name".ovpn
    }

    # determine public IP (prefer local interface IP if differs from external)
    IP1=$(ip -4 addr show scope global | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n1)
    IP2=$(wget -4qO- "http://whatismyip.akamai.com/" 2>/dev/null || true)

    if [[ -z "$IP1" ]]; then
        IP1=$(hostname -I | awk '{print $1}')
    fi

    if [[ -n "$IP1" && -n "$IP2" && "$IP1" != "$IP2" ]]; then
        IP="$IP1"
    else
        IP="${IP2:-$IP1}"
    fi

    # helper: replace remote line in client-common robustly
    replace_client_remote() {
        local ipa="$1"
        local port="$2"
        # replace line starting with 'remote ' (host port) with new ip and port
        if [[ -f /etc/openvpn/client-common.txt ]]; then
            # Try to replace a line like: remote <host> <port>
            if grep -qE '^remote[[:space:]]+' /etc/openvpn/client-common.txt; then
                sed -i -E "s|^remote[[:space:]]+\S+[[:space:]]+[0-9]+|remote ${ipa} ${port}|" /etc/openvpn/client-common.txt
            else
                # append if missing
                echo "remote ${ipa} ${port}" >> /etc/openvpn/client-common.txt
            fi
        fi
    }

    # helper: detect NIC in a portable way
    detect_nic() {
        ip -4 route ls default 2>/dev/null | awk '/default/ {print $5; exit}'
    }

    # helper: find openvpn auth plugin if available
    find_auth_plugin() {
        find /usr/lib /usr/local/lib -type f -name 'openvpn-plugin-auth-pam.so' 2>/dev/null | head -n1 || true
    }

    # helper: detect systemd service name to use
    detect_openvpn_service() {
        # candidate names
        for s in "openvpn@server.service" "openvpn-server@server.service" "openvpn.service"; do
            if systemctl list-unit-files --type=service 2>/dev/null | grep -q "^${s}"; then
                echo "$s"
                return 0
            fi
        done
        # fallback: check active units containing 'openvpn'
        systemctl --type=service --state=running | grep openvpn | awk '{print $1}' | head -n1 || echo "openvpn@server.service"
    }

    # When openvpn running -> manager menu
    if ss -tlpn 2>/dev/null | grep -qw 'openvpn'; then
        while :; do
            clear
            opnp=$(awk '/^port /{print $2; exit}' /etc/openvpn/server.conf 2>/dev/null || echo "1194")
            [[ -d /var/www/html/openvpn ]] && ovpnweb=$(echo -e "\033[1;32m◉ ") || ovpnweb=$(echo -e "\033[1;31m○ ")
            if grep -q '^duplicate-cn' /etc/openvpn/server.conf 2>/dev/null; then
                mult=$(echo -e "\033[1;32m◉ ")
            else
                mult=$(echo -e "\033[1;31m○ ")
            fi

            echo -e "\E[44;1;37m          GERENCIAR OPENVPN           \E[0m"
            echo ""
            echo -e "\033[1;33mPORTA\033[1;37m: \033[1;32m$opnp"
            echo ""
            echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA"
            echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER OPENVPN"
            echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mOVPN VIA LINK $ovpnweb"
            echo -e "\033[1;31m[\033[1;36m4\033[1;31m] \033[1;37m• \033[1;33mMULTILOGIN OVPN $mult"
            echo -e "\033[1;31m[\033[1;36m5\033[1;31m] \033[1;37m• \033[1;33mALTERAR HOST DNS"
            echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR"
            echo ""
            echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;31m?\033[1;37m "
            read option
            case $option in
            1)
                clear
                echo -e "\E[44;1;37m         ALTERAR PORTA OPENVPN         \E[0m"
                echo ""
                echo -e "\033[1;33mPORTA EM USO: \033[1;32m$opnp"
                echo ""
                echo -ne "\033[1;32mQUAL PORTA DESEJA UTILIZAR \033[1;33m?\033[1;37m "
                read porta
                [[ -z "$porta" ]] && {
                    echo -e "\n\033[1;31mPorta invalida!"
                    sleep 3
                    fun_conexao
                }
                verif_ptrs "$porta"
                echo ""
                echo -e "\033[1;32mALTERANDO A PORTA OPENVPN!\033[1;33m"
                echo ""
                fun_opn() {
                    # replace server port
                    if [[ -f /etc/openvpn/server.conf ]]; then
                        sed -i "s/^port .*/port $porta/" /etc/openvpn/server.conf
                    fi
                    # replace client remote entry robustly
                    replace_client_remote "$IP" "$porta"
                    sleep 1
                    # detect service and restart safely
                    svc=$(detect_openvpn_service)
                    systemctl restart "$svc" 2>/dev/null || systemctl restart openvpn@server 2>/dev/null || true
                }
                fun_bar 'fun_opn'
                echo ""
                echo -e "\033[1;32mPORTA ALTERADA COM SUCESSO!\033[1;33m"
                sleep 2
                fun_conexao
                ;;
            2)
                echo ""
                echo -ne "\033[1;32mDESEJA REMOVER O OPENVPN \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
                read REMOVE
                [[ "$REMOVE" = 's' ]] && {
                    rmv_open() {
                        PORT=$(awk '/^port /{print $2; exit}' /etc/openvpn/server.conf 2>/dev/null || echo "")
                        PROTOCOL=$(awk '/^proto /{print $2; exit}' /etc/openvpn/server.conf 2>/dev/null || echo "")
                        IP_SAVED=$(grep -m1 -oP '(?<=--to )\S+' /etc/rc.local 2>/dev/null || true)
                        # firewall-cmd cleanup if present
                        if command -v firewall-cmd >/dev/null 2>&1 && pgrep firewalld >/dev/null 2>&1; then
                            firewall-cmd --zone=public --remove-port=${PORT}/${PROTOCOL} 2>/dev/null || true
                            firewall-cmd --zone=trusted --remove-source=10.8.0.0/24 2>/dev/null || true
                            firewall-cmd --permanent --zone=public --remove-port=${PORT}/${PROTOCOL} 2>/dev/null || true
                            firewall-cmd --permanent --zone=trusted --remove-source=10.8.0.0/24 2>/dev/null || true
                        fi
                        # remove iptables rules if present
                        if iptables -L -n 2>/dev/null | grep -qE 'REJECT|DROP|ACCEPT'; then
                            iptables -D INPUT -p ${PROTOCOL} --dport ${PORT} -j ACCEPT 2>/dev/null || true
                            iptables -D FORWARD -s 10.8.0.0/24 -j ACCEPT 2>/dev/null || true
                            iptables -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
                            sed -i "/iptables -I INPUT -p ${PROTOCOL} --dport ${PORT} -j ACCEPT/d" "$RCLOCAL" 2>/dev/null || true
                            sed -i "/iptables -I FORWARD -s 10.8.0.0\/24 -j ACCEPT/d" "$RCLOCAL" 2>/dev/null || true
                            sed -i "/iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT/d" "$RCLOCAL" 2>/dev/null || true
                        fi
                        # nat rule removal
                        iptables -t nat -D POSTROUTING -s 10.8.0.0/24 -j SNAT --to "$IP_SAVED" 2>/dev/null || true
                        sed -i '/iptables -t nat -A POSTROUTING -s 10.8.0.0\/24 -j SNAT --to /d' "$RCLOCAL" 2>/dev/null || true

                        # SELinux cleanup if semanage exists
                        if command -v semanage >/dev/null 2>&1; then
                            if sestatus 2>/dev/null | grep -q "Current mode.*enforcing"; then
                                if [[ -n "$PORT" ]]; then
                                    semanage port -d -t openvpn_port_t -p ${PROTOCOL} ${PORT} 2>/dev/null || true
                                fi
                            fi
                        fi

                        if command -v apt-get >/dev/null 2>&1; then
                            apt-get remove --purge -y openvpn easy-rsa 2>/dev/null || true
                            apt-get autoremove -y 2>/dev/null || true
                            apt-get autoclean -y 2>/dev/null || true
                        elif command -v yum >/dev/null 2>&1; then
                            yum remove openvpn easy-rsa -y 2>/dev/null || true
                        fi

                        rm -rf /etc/openvpn 2>/dev/null || true
                        rm -rf /usr/share/doc/openvpn* 2>/dev/null || true
                    }
                    echo ""
                    echo -e "\033[1;32mREMOVENDO O OPENVPN!\033[0m"
                    echo ""
                    fun_bar 'rmv_open'
                    echo ""
                    echo -e "\033[1;32mOPENVPN REMOVIDO COM SUCESSO!\033[0m"
                    sleep 2
                    fun_conexao
                } || {
                    echo ""
                    echo -e "\033[1;31mRetornando...\033[0m"
                    sleep 2
                    fun_conexao
                }
                ;;
            3)
                if [[ -d /var/www/html/openvpn ]]; then
                    clear
                    fun_spcr() {
                        apt-get remove apache2 -y 2>/dev/null || true
                        apt-get autoremove -y 2>/dev/null || true
                        rm -rf /var/www/html/openvpn 2>/dev/null || true
                    }
                    echo -ne "\033[1;31mDESATIVANDO\033[1;32m.\033[1;33m.\033[1;31m. \033[1;33m"
                    fun_bar 'fun_spcr'
                    sleep 2
                    fun_openvpn
                else
                    clear
                    fun_apchon() {
                        apt-get install -y apache2 zip 2>/dev/null || true
                        sed -i "s/Listen 80/Listen 81/g" /etc/apache2/ports.conf 2>/dev/null || true
                        systemctl restart apache2 2>/dev/null || true
                        [[ ! -d /var/www/html ]] && mkdir -p /var/www/html
                        [[ ! -d /var/www/html/openvpn ]] && mkdir -p /var/www/html/openvpn
                        touch /var/www/html/openvpn/index.html
                        chmod -R 755 /var/www 2>/dev/null || true
                        systemctl restart apache2 2>/dev/null || true
                    }
                    echo -ne "\033[1;32mATIVANDO\033[1;32m.\033[1;33m.\033[1;31m. \033[1;33m"
                    fun_bar 'fun_apchon'
                    fun_openvpn
                fi
                ;;
            4)
                if grep -q '^duplicate-cn' /etc/openvpn/server.conf 2>/dev/null; then
                    clear
                    fun_multon() {
                        sed -i '/^duplicate-cn/d' /etc/openvpn/server.conf 2>/dev/null || true
                        sleep 1.5
                        svc=$(detect_openvpn_service)
                        systemctl restart "$svc" 2>/dev/null || true
                        sleep 2
                    }
                    fun_bar 'fun_multon'
                    sleep 1
                    fun_openvpn
                else
                    clear
                    fun_multoff() {
                        # ensure duplicate-cn is present (append if not)
                        if ! grep -q '^duplicate-cn' /etc/openvpn/server.conf 2>/dev/null; then
                            echo "duplicate-cn" >> /etc/openvpn/server.conf
                        fi
                        sleep 1.5
                        svc=$(detect_openvpn_service)
                        systemctl restart "$svc" 2>/dev/null || true
                    }
                    fun_bar 'fun_multoff'
                    sleep 1
                    fun_openvpn
                fi
                ;;
            5)
                # DNS host menu (unchanged)
                clear
                echo -e "\E[44;1;37m         ALTERAR HOST DNS           \E[0m"
                echo ""
                echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mADICIONAR HOST DNS"
                echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER HOST DNS"
                echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mEDITAR MANUALMENTE"
                echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR"
                echo ""
                echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;31m?\033[1;37m "
                read resp
                [[ -z "$resp" ]] && {
                    echo ""
                    echo -e "\033[1;31mOpcao invalida!"
                    sleep 3
                    fun_openvpn
                }
                if [[ "$resp" = '1' ]]; then
                    clear
                    echo -e "\E[44;1;37m            Adicionar Host DNS            \E[0m"
                    echo ""
                    echo -e "\033[1;33mLista dos hosts atuais:\033[0m "
                    echo ""
                    for _host in $(awk '/127\.0\.0\.1/ && !/localhost/ {print $2}' /etc/hosts); do
                        echo -e "\033[1;32m$_host"
                    done
                    echo ""
                    echo -ne "\033[1;33mDigite o host a ser adicionado\033[1;37m : "
                    read host
                    if [[ -z $host ]]; then
                        echo ""
                        echo -e "\E[41;1;37m        Campo Vazio ou invalido !       \E[0m"
                        sleep 2
                        fun_openvpn
                    fi
                    if grep -qw "$host" /etc/hosts; then
                        echo -e "\E[41;1;37m    Esse host ja está adicionado  !    \E[0m"
                        sleep 2
                        fun_openvpn
                    fi
                    sed -i "3i127.0.0.1 $host" /etc/hosts
                    echo ""
                    echo -e "\E[44;1;37m      Host adicionado com sucesso !      \E[0m"
                    sleep 2
                    fun_openvpn
                elif [[ "$resp" = '2' ]]; then
                    clear
                    echo -e "\E[44;1;37m            Remover Host DNS            \E[0m"
                    echo ""
                    echo -e "\033[1;33mLista dos hosts atuais:\033[0m "
                    echo ""
                    i=0
                    oP=""
                    for _host in $(awk '/127\.0\.0\.1/ && !/localhost/ {print $2}' /etc/hosts); do
                        i=$((i+1))
                        oP+="$i:$_host\n"
                        echo -e "\033[1;33m[\033[1;31m$i\033[1;33m] \033[1;37m- \033[1;32m$_host\033[0m"
                    done
                    echo ""
                    echo -ne "\033[1;32mSelecione o host a ser removido \033[1;33m[1-$i]\033[1;37m: "
                    read option
                    if [[ -z $option ]]; then
                        echo ""
                        echo -e "\E[41;1;37m          Opcao invalida  !        \E[0m"
                        sleep 2
                        fun_openvpn
                    fi
                    host=$(echo -e "$oP" | grep -E "^$option:" | cut -d: -f2)
                    grep -v "127.0.0.1 $host" /etc/hosts > /tmp/hosts.tmp && mv /tmp/hosts.tmp /etc/hosts
                    echo ""
                    echo -e "\E[41;1;37m      Host removido com sucesso !      \E[0m"
                    sleep 2
                    fun_openvpn
                elif [[ "$resp" = '3' ]]; then
                    echo -e "\n\033[1;32mALTERANDO ARQUIVO \033[1;37m/etc/hosts\033[0m"
                    echo -e "\n\033[1;31mATENCAO!\033[0m"
                    echo -e "\n\033[1;33mPARA SALVAR USE AS TECLAS \033[1;32mctrl x y\033[0m"
                    sleep 4
                    clear
                    nano /etc/hosts
                    echo -e "\n\033[1;32mALTERADO COM SUCESSO!\033[0m"
                    sleep 3
                    fun_openvpn
                elif [[ "$resp" = '0' ]]; then
                    echo ""
                    echo -e "\033[1;31mRetornando...\033[0m"
                    sleep 2
                    fun_conexao
                else
                    echo ""
                    echo -e "\033[1;31mOpcao invalida !\033[0m"
                    sleep 2
                    fun_openvpn
                fi
                ;;
            0)
                fun_conexao
                ;;
            *)
                echo ""
                echo -e "\033[1;31mOpcao invalida !\033[0m"
                sleep 2
                fun_openvpn
                ;;
            esac
        done
    else
        # INSTALL PATH
        clear
        echo -e "\E[44;1;37m              INSTALADOR OPENVPN               \E[0m"
        echo ""
        echo -e "\033[1;33mRESPONDA AS QUESTOES PARA INICIAR A INSTALACAO"
        echo ""
        echo -ne "\033[1;32mPARA CONTINUAR CONFIRME SEU IP: \033[1;37m"
        read -e -i "$IP" IP
        [[ -z "$IP" ]] && {
            echo ""
            echo -e "\033[1;31mIP invalido!"
            sleep 3
            fun_conexao
        }
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR? \033[1;37m")" -e -i 1194 porta
        [[ -z "$porta" ]] && {
            echo ""
            echo -e "\033[1;31mPorta invalida!"
            sleep 2
            fun_conexao
        }
        echo ""
        echo -e "\033[1;33mVERIFICANDO PORTA..."
        verif_ptrs "$porta"
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;33mSistema"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;33mGoogle (\033[1;32mRecomendado\033[1;33m)"
        echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;33mOpenDNS"
        echo -e "\033[1;31m[\033[1;36m4\033[1;31m] \033[1;33mCloudflare"
        echo -e "\033[1;31m[\033[1;36m5\033[1;31m] \033[1;33mHurricane Electric"
        echo -e "\033[1;31m[\033[1;36m6\033[1;31m] \033[1;33mVerisign"
        echo -e "\033[1;31m[\033[1;36m7\033[1;31m] \033[1;33mDNS Performace\033[0m"
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL DNS DESEJA UTILIZAR? \033[1;37m")" -e -i 2 DNS
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;33mUDP"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;33mTCP (\033[1;32mRecomendado\033[1;33m)"
        echo ""
        read -p "$(echo -e "\033[1;32mQUAL PROTOCOLO DESEJA UTILIZAR NO OPENVPN? \033[1;37m")" -e -i 2 resp
        if [[ "$resp" = '1' ]]; then
            PROTOCOL=udp
        else
            PROTOCOL=tcp
        fi

        echo ""
        echo -e "\033[1;32mATUALIZANDO O SISTEMA"
        echo ""
        fun_attos() {
            apt update -y
            apt upgrade -y
        }
        fun_bar 'fun_attos'

        echo ""
        echo -e "\033[1;32mINSTALANDO DEPENDENCIAS"
        echo ""
        fun_instdep() {
            DEBIAN_FRONTEND=noninteractive apt-get install -y openvpn easy-rsa iptables iptables-persistent openssl ca-certificates zip
        }
        fun_bar 'fun_instdep'

        [[ -d /etc/openvpn/easy-rsa/ ]] && rm -rf /etc/openvpn/easy-rsa/

        echo ""
        fun_dep() {
            mkdir -p /etc/openvpn/easy-rsa
            # compat: some distros place easy-rsa in /usr/share/easy-rsa
            if [[ -d /usr/share/easy-rsa ]]; then
                cp -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/ 2>/dev/null || true
            elif command -v easyrsa >/dev/null 2>&1; then
                # try using easyrsa binary if available
                easyrsa init-pki >/dev/null 2>&1 || true
                # Note: this fallback may require manual handling
            fi
            chown -R root:root /etc/openvpn/easy-rsa/
            cd /etc/openvpn/easy-rsa/ || return 1
            ./easyrsa init-pki >/dev/null 2>&1 || true
            ./easyrsa --batch build-ca nopass >/dev/null 2>&1 || true
            ./easyrsa gen-dh >/dev/null 2>&1 || true
            ./easyrsa build-server-full server nopass >/dev/null 2>&1 || true
            ./easyrsa build-client-full SSHPLUS nopass >/dev/null 2>&1 || true
            ./easyrsa gen-crl >/dev/null 2>&1 || true
            cp pki/ca.crt pki/private/ca.key pki/dh.pem pki/issued/server.crt pki/private/server.key pki/crl.pem /etc/openvpn 2>/dev/null || true
            chown nobody:nogroup /etc/openvpn/crl.pem 2>/dev/null || true
            openvpn --genkey secret /etc/openvpn/ta.key 2>/dev/null || true

            # plugin path detection
            PLUGIN_PATH=$(find_auth_plugin)
            if [[ -z "$PLUGIN_PATH" ]]; then
                # fallback to common path
                PLUGIN_PATH="/usr/lib/x86_64-linux-gnu/openvpn/plugins/openvpn-plugin-auth-pam.so"
            fi

            # write server.conf (use detected plugin path)
            cat > /etc/openvpn/server.conf <<EOF
port $porta
proto $PROTOCOL
dev tun
sndbuf 0
rcvbuf 0
ca ca.crt
cert server.crt
key server.key
dh dh.pem
tls-auth ta.key 0
topology subnet
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt
push "redirect-gateway def1 bypass-dhcp"
EOF

            case $DNS in
            1)
                awk '/nameserver/ {print $2}' /etc/resolv.conf | while read -r line; do
                    echo "push \"dhcp-option DNS $line\"" >>/etc/openvpn/server.conf
                done
                ;;
            2)
                echo 'push "dhcp-option DNS 8.8.8.8"' >>/etc/openvpn/server.conf
                echo 'push "dhcp-option DNS 8.8.4.4"' >>/etc/openvpn/server.conf
                ;;
            3)
                echo 'push "dhcp-option DNS 208.67.222.222"' >>/etc/openvpn/server.conf
                echo 'push "dhcp-option DNS 208.67.220.220"' >>/etc/openvpn/server.conf
                ;;
            4)
                echo 'push "dhcp-option DNS 1.1.1.1"' >>/etc/openvpn/server.conf
                echo 'push "dhcp-option DNS 1.0.0.1"' >>/etc/openvpn/server.conf
                ;;
            5)
                echo 'push "dhcp-option DNS 74.82.42.42"' >>/etc/openvpn/server.conf
                ;;
            6)
                echo 'push "dhcp-option DNS 64.6.64.6"' >>/etc/openvpn/server.conf
                echo 'push "dhcp-option DNS 64.6.65.6"' >>/etc/openvpn/server.conf
                ;;
            7)
                echo 'push "dhcp-option DNS 189.38.95.95"' >>/etc/openvpn/server.conf
                echo 'push "dhcp-option DNS 216.146.36.36"' >>/etc/openvpn/server.conf
                ;;
            esac

            cat >>/etc/openvpn/server.conf <<EOF
keepalive 10 120
float
cipher AES-256-CBC
comp-lzo yes
user nobody
group nogroup
persist-key
persist-tun
status openvpn-status.log
management localhost 7505
verb 3
crl-verify crl.pem
client-to-client
client-cert-not-required
username-as-common-name
plugin $PLUGIN_PATH login
duplicate-cn
EOF

            # enable ip forward
            echo 'net.ipv4.ip_forward=1' > /etc/sysctl.d/99-openvpn.conf
            sysctl --system >/dev/null 2>&1 || true

            NIC=$(detect_nic)
            if [[ -z "$NIC" ]]; then
                NIC=$(ip -4 route ls | awk '/default/ {print $5; exit}')
            fi

            # iptables rules
            iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o "$NIC" -j MASQUERADE
            iptables -A FORWARD -s 10.8.0.0/24 -j ACCEPT
            iptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
            iptables -A INPUT -p $PROTOCOL --dport $porta -j ACCEPT

            # persist rules using iptables-persistent or netfilter-persistent
            if command -v netfilter-persistent >/dev/null 2>&1; then
                netfilter-persistent save >/dev/null 2>&1 || true
            elif command -v iptables-save >/dev/null 2>&1; then
                mkdir -p /etc/iptables
                iptables-save > /etc/iptables.rules
                echo "@reboot root iptables-restore < /etc/iptables.rules" > /etc/cron.d/openvpn_iptables
            fi
        }

        echo -e "\033[1;32mINSTALANDO O OPENVPN  \033[1;31m(\033[1;33mPODE DEMORAR!\033[1;31m)"
        echo ""
        fun_bar 'fun_dep > /dev/null 2>&1'

        fun_ropen() {
    # Wait for config file to be fully written
    sleep 2
    
    # Verify server.conf exists
    if [[ ! -f /etc/openvpn/server.conf ]]; then
        echo "ERROR: /etc/openvpn/server.conf not found!"
        return 1
    fi
    
    # Ubuntu 22.04 uses openvpn-server@.service template
    # Try the correct service names in order
    local service_started=0
    
    # Try openvpn-server@server first (Ubuntu 22.04 default)
    if systemctl enable openvpn-server@server.service 2>&1; then
        echo "Service enabled: openvpn-server@server.service"
        if systemctl start openvpn-server@server.service 2>&1; then
            echo "Service started successfully"
            service_started=1
        fi
    fi
    
    # Fallback to openvpn@server if above failed
    if [[ $service_started -eq 0 ]]; then
        if systemctl enable openvpn@server.service 2>&1; then
            echo "Service enabled: openvpn@server.service"
            if systemctl start openvpn@server.service 2>&1; then
                echo "Service started successfully"
                service_started=1
            fi
        fi
    fi
    
    # Check if service actually started
    sleep 2
    if systemctl is-active --quiet openvpn-server@server.service || \
       systemctl is-active --quiet openvpn@server.service; then
        echo "OpenVPN is running"
        return 0
    else
        echo "ERROR: Failed to start OpenVPN service"
        echo "Checking service status..."
        systemctl status openvpn-server@server.service 2>&1 || \
        systemctl status openvpn@server.service 2>&1
        return 1
    fi
}

        echo ""
        echo -e "\033[1;32mREINICIANDO O OPENVPN"
        echo ""
        fun_bar 'fun_ropen'

        # re-evaluate external IP if necessary
        IP2=$(wget -4qO- "http://whatismyip.akamai.com/" 2>/dev/null || true)
        if [[ -n "$IP2" && "$IP" != "$IP2" ]]; then
            IP="$IP2"
        fi

        # write client-common.txt robustly
        cat >/etc/openvpn/client-common.txt <<EOF
client
dev tun
proto $PROTOCOL
sndbuf 0
rcvbuf 0
remote $IP $porta
resolv-retry 5
nobind
persist-key
persist-tun
remote-cert-tls server
cipher AES-256-CBC
comp-lzo yes
setenv opt block-outside-dns
key-direction 1
verb 3
auth-user-pass
keepalive 10 120
float
EOF

        # gerar client.ovpn
        newclient "SSHPLUS"

        if ss -tlpn 2>/dev/null | grep -qw 'openvpn'; then
            echo -e "\n\033[1;32mOPENVPN INSTALADO COM SUCESSO\033[0m"
        else
            echo -e "\n\033[1;31mERRO ! A INSTALACAO CORROMPEU\033[0m"
        fi
    fi

    sleep 1
    fun_conexao
}








fun_socks() {
		clear
		echo -e "\E[44;1;37m            GERENCIAR PROXY SOCKS             \E[0m"
		echo ""
		if ss -tlpn 2>/dev/null | grep 'python' 1>/dev/null 2>/dev/null; then
			sks='\033[1;32mON'
			echo -e "\033[1;33mPORTAS\033[1;37m: \033[1;32m$(ss -tlpn 2>/dev/null | grep 'python' | awk '{print $4}' | cut -d: -f2 | xargs)"
		else
			sks='\033[1;31mOFF'
		fi
		
		[[ $(screen -list | grep -wc 'proxy') != '0' ]] && var_sks1="\033[1;32m◉" || var_sks1="\033[1;31m○"
		[[ $(screen -list | grep -wc 'ws') != '0' ]] && var_sks2="\033[1;32m◉" || var_sks2="\033[1;31m○"
		[[ $(screen -list | grep -wc 'openpy') != '0' ]] && sksop="\033[1;32m◉" || sksop="\033[1;31m○"
		
		echo ""
		echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mSOCKS SSH $var_sks1 \033[0m"
		echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mWEBSOCKET $var_sks2 \033[0m"
		echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mSOCKS OPENVPN $sksop \033[0m"
		echo -e "\033[1;31m[\033[1;36m4\033[1;31m] \033[1;37m• \033[1;33mABRIR PORTA\033[0m"
		echo -e "\033[1;31m[\033[1;36m5\033[1;31m] \033[1;37m• \033[1;33mALTERAR STATUS SOCKS SSH\033[0m"
		echo -e "\033[1;31m[\033[1;36m6\033[1;31m] \033[1;37m• \033[1;33mALTERAR STATUS WEBSOCKET\033[0m"
		echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
		echo ""
		echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;37m "
		read resposta
		
		if [[ "$resposta" = '1' ]]; then
			if ps x | grep -w proxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				clear
				echo -e "\E[41;1;37m             PROXY SOCKS              \E[0m"
				echo ""
				fun_socksoff() {
					for pidproxy in $(screen -ls | grep ".proxy" | awk {'print $1'}); do
						screen -r -S "$pidproxy" -X quit
					done
					[[ $(grep -wc "proxy.py" /etc/autostart 2>/dev/null) != '0' ]] && {
						sed -i '/proxy.py/d' /etc/autostart
					}
					sleep 1
					screen -wipe >/dev/null
				}
				echo -e "\033[1;32mDESATIVANDO O PROXY SOCKS\033[1;33m"
				echo ""
				fun_bar 'fun_socksoff'
				echo ""
				echo -e "\033[1;32mPROXY SOCKS DESATIVADO COM SUCESSO!\033[1;33m"
				sleep 3
				fun_socks
			else
				clear
				echo -e "\E[44;1;37m             PROXY SOCKS              \E[0m"
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 3
					clear
					fun_conexao
				}
				verif_ptrs $porta
				fun_inisocks() {
					sleep 1
					screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta
					[[ ! -f /etc/autostart ]] && touch /etc/autostart
					[[ $(grep -wc "proxy.py" /etc/autostart) = '0' ]] && {
						echo -e "ss -tlpn | grep -w $porta > /dev/null || { screen -r -S 'proxy' -X quit; screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta; }" >>/etc/autostart
					} || {
						sed -i '/proxy.py/d' /etc/autostart
						echo -e "ss -tlpn | grep -w $porta > /dev/null || { screen -r -S 'proxy' -X quit; screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta; }" >>/etc/autostart
					}
				}
				echo ""
				echo -e "\033[1;32mINICIANDO O PROXY SOCKS\033[1;33m"
				echo ""
				fun_bar 'fun_inisocks'
				echo ""
				echo -e "\033[1;32mSOCKS ATIVADO COM SUCESSO\033[1;33m"
				sleep 3
				fun_socks
			fi
		elif [[ "$resposta" = '2' ]]; then
			if ps x | grep -w wsproxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				clear
				echo -e "\E[41;1;37m             WEBSOCKET              \E[0m"
				echo ""
				fun_wssocksoff() {
					for pidproxy in $(screen -ls | grep ".ws" | awk {'print $1'}); do
						screen -r -S "$pidproxy" -X quit
					done
					[[ $(grep -wc "wsproxy.py" /etc/autostart 2>/dev/null) != '0' ]] && {
						sed -i '/wsproxy.py/d' /etc/autostart
					}
					sleep 1
					screen -wipe >/dev/null
				}
				echo -e "\033[1;32mDESATIVANDO O WEBSOCKET\033[1;33m"
				echo ""
				fun_bar 'fun_wssocksoff'
				echo ""
				echo -e "\033[1;32mWEBSOCKET DESATIVADO COM SUCESSO!\033[1;33m"
				sleep 3
				fun_socks
			else
				clear
				echo -e "\E[44;1;37m             WEBSOCKET              \E[0m"
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 3
					clear
					fun_conexao
				}
				verif_ptrs $porta
				fun_iniwssocks() {
					sleep 1
					screen -dmS ws python3 /etc/SSHPlus/wsproxy.py $porta
					[[ ! -f /etc/autostart ]] && touch /etc/autostart
					[[ $(grep -wc "wsproxy.py" /etc/autostart) = '0' ]] && {
						echo -e "ss -tlpn | grep -w $porta > /dev/null || { screen -r -S 'ws' -X quit; screen -dmS ws python3 /etc/SSHPlus/wsproxy.py $porta; }" >>/etc/autostart
					} || {
						sed -i '/wsproxy.py/d' /etc/autostart
						echo -e "ss -tlpn | grep -w $porta > /dev/null || { screen -r -S 'ws' -X quit; screen -dmS ws python3 /etc/SSHPlus/wsproxy.py $porta; }" >>/etc/autostart
					}
				}
				echo ""
				echo -e "\033[1;32mINICIANDO O WEBSOCKET\033[1;33m"
				echo ""
				fun_bar 'fun_iniwssocks'
				echo ""
				echo -e "\033[1;32mWEBSOCKET ATIVADO COM SUCESSO\033[1;33m"
				sleep 3
				fun_socks
			fi
		elif [[ "$resposta" = '3' ]]; then
			if ps x | grep -w open.py | grep -v grep 1>/dev/null 2>/dev/null; then
				clear
				echo -e "\E[41;1;37m            SOCKS OPENVPN             \E[0m"
				echo ""
				fun_socksopenoff() {
					for pidproxy in $(screen -list | grep -w "openpy" | awk {'print $1'}); do
						screen -r -S "$pidproxy" -X quit
					done
					[[ $(grep -wc "open.py" /etc/autostart 2>/dev/null) != '0' ]] && {
						sed -i '/open.py/d' /etc/autostart
					}
					sleep 1
					screen -wipe >/dev/null
				}
				echo -e "\033[1;32mDESATIVANDO O SOCKS OPEN\033[1;33m"
				echo ""
				fun_bar 'fun_socksopenoff'
				echo ""
				echo -e "\033[1;32mSOCKS DESATIVADO COM SUCESSO!\033[1;33m"
				sleep 2
				fun_socks
			else
				clear
				echo -e "\E[41;1;37m            SOCKS OPENVPN             \E[0m"
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 2
					clear
					fun_conexao
				}
				verif_ptrs $porta
				fun_inisocksop() {
					if ss -tlpn 2>/dev/null | grep 'openvpn' 1>/dev/null 2>/dev/null; then
						listoldop=$(grep -w 'DEFAULT_HOST =' /etc/SSHPlus/open.py 2>/dev/null | cut -d"'" -f2 | cut -d: -f2)
						listopen=$(ss -tlpn 2>/dev/null | grep -w openvpn | grep -v 127.0.0.1 | awk '{print $4}' | cut -d: -f2)
						sed -i "s/$listoldop/$listopen/" /etc/SSHPlus/open.py
					fi
					sleep 1
					screen -dmS openpy python3 /etc/SSHPlus/open.py $porta
					[[ ! -f /etc/autostart ]] && touch /etc/autostart
					[[ $(grep -wc "open.py" /etc/autostart) = '0' ]] && {
						echo -e "ss -tlpn | grep -w $porta > /dev/null || { screen -r -S 'openpy' -X quit; screen -dmS openpy python3 /etc/SSHPlus/open.py $porta; }" >>/etc/autostart
					} || {
						sed -i '/open.py/d' /etc/autostart
						echo -e "ss -tlpn | grep -w $porta > /dev/null || { screen -r -S 'openpy' -X quit; screen -dmS openpy python3 /etc/SSHPlus/open.py $porta; }" >>/etc/autostart
					}
				}
				echo ""
				echo -e "\033[1;32mINICIANDO O SOCKS OPENVPN\033[1;33m"
				echo ""
				fun_bar 'fun_inisocksop'
				echo ""
				echo -e "\033[1;32mSOCKS OPENVPN ATIVADO COM SUCESSO\033[1;33m"
				sleep 3
				fun_socks
			fi
		elif [[ "$resposta" = '4' ]]; then
			if ps x | grep proxy.py | grep -v grep 1>/dev/null 2>/dev/null; then
				sockspt=$(ss -tlpn 2>/dev/null | grep 'python' | awk '{print $4}' | cut -d: -f2 | xargs)
				clear
				echo -e "\E[44;1;37m            PROXY SOCKS             \E[0m"
				echo ""
				echo -e "\033[1;33mPORTAS EM USO: \033[1;32m$sockspt"
				echo ""
				echo -ne "\033[1;32mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mPorta invalida!"
					sleep 2
					clear
					fun_conexao
				}
				verif_ptrs $porta
				echo ""
				echo -e "\033[1;32mINICIANDO O PROXY SOCKS NA PORTA \033[1;31m$porta\033[1;33m"
				echo ""
				abrirptsks() {
					sleep 1
					screen -dmS proxy python3 /etc/SSHPlus/proxy.py $porta
					sleep 1
				}
				fun_bar 'abrirptsks'
				echo ""
				echo -e "\033[1;32mPROXY SOCKS ATIVADO COM SUCESSO\033[1;33m"
				sleep 2
				fun_socks
			else
				clear
				echo -e "\033[1;31mFUNCAO INDISPONIVEL\n\n\033[1;33mATIVE O SOCKS PRIMEIRO !\033[1;33m"
				sleep 2
				fun_socks
			fi
		elif [[ "$resposta" = '0' ]]; then
			echo ""
			echo -e "\033[1;31mRetornando...\033[0m"
			sleep 1
			fun_conexao
		else
			echo ""
			echo -e "\033[1;31mOpcao invalida !\033[0m"
			sleep 1
			fun_socks
		fi
	}

x="ok"
	fun_conexao() {
		while true; do
			[[ ! -e '/home/sshplus' ]] && exit 0
			clear
			echo -e "\E[44;1;37m                MODO DE CONEXAO                 \E[0m\n"
			
			echo -e "\033[1;32mSERVICO: \033[1;33mOPENSSH \033[1;32mPORTA: \033[1;37m$(grep 'Port' /etc/ssh/sshd_config | cut -d' ' -f2 | grep -v 'no' | xargs)"
			sts6="\033[1;32m◉ "
			
			[[ $(systemctl is-active openvpn@server 2>/dev/null) == "active" ]] && {
				echo -e "\033[1;32mSERVICO: \033[1;33mOPENVPN: \033[1;32mPORTA: \033[1;37m$(grep '^port' /etc/openvpn/server.conf 2>/dev/null | awk '{print $2}')"
				sts5="\033[1;32m◉ "
			} || {
				sts5="\033[1;31m○ "
			}
			
			[[ $(systemctl is-active squid 2>/dev/null) == "active" ]] && {
				echo -e "\033[1;32mSERVICO: \033[1;33mSQUID \033[1;32mPORTA: \033[1;37m$(ss -tlpn 2>/dev/null | grep 'squid' | awk '{print $4}' | cut -d: -f2 | xargs)"
				sts1="\033[1;32m◉ "
			} || {
				sts1="\033[1;31m○ "
			}
			
			[[ $(systemctl is-active dropbear 2>/dev/null) == "active" ]] && {
				echo -e "\033[1;32mSERVICO: \033[1;33mDROPBEAR \033[1;32mPORTA: \033[1;37m$(ss -tlpn 2>/dev/null | grep 'dropbear' | awk '{print $4}' | cut -d: -f2 | xargs)"
				sts2="\033[1;32m◉ "
			} || {
				sts2="\033[1;31m○ "
			}
			
			[[ -e "/etc/stunnel/stunnel.conf" ]] && {
				echo -e "\033[1;32mSERVICO: \033[1;33mSSL TUNNEL \033[1;32mPORTA: \033[1;37m$(ss -tlpn 2>/dev/null | grep 'stunnel' | awk '{print $4}' | cut -d: -f2 | xargs)"
				sts3="\033[1;32m◉ "
			} || {
				sts3="\033[1;31m○ "
			}
			
			[[ $(ss -tlpn 2>/dev/null | grep 'sslh' | wc -l) != '0' ]] && {
				echo -e "\033[1;32mSERVICO: \033[1;33mSSLH: \033[1;32mPORTA: \033[1;37m$(ss -tlpn 2>/dev/null | grep 'sslh' | awk '{print $4}' | cut -d: -f2 | xargs)"
				sts7="\033[1;32m◉ "
			} || {
				sts7="\033[1;31m○ "
			}
			
			echo -e "\033[0;34m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\033[0m"
			echo ""
			echo -e "\033[1;31m[\033[1;36m01\033[1;31m] \033[1;37m• \033[1;33mOPENSSH $sts6"
			echo -e "\033[1;31m[\033[1;36m02\033[1;31m] \033[1;37m• \033[1;33mSQUID PROXY $sts1"
			echo -e "\033[1;31m[\033[1;36m03\033[1;31m] \033[1;37m• \033[1;33mDROPBEAR $sts2"
			echo -e "\033[1;31m[\033[1;36m04\033[1;31m] \033[1;37m• \033[1;33mOPENVPN $sts5"
			echo -e "\033[1;31m[\033[1;36m05\033[1;31m] \033[1;37m• \033[1;33mPROXY SOCKS"
			echo -e "\033[1;31m[\033[1;36m06\033[1;31m] \033[1;37m• \033[1;33mSSL TUNNEL $sts3"
			echo -e "\033[1;31m[\033[1;36m07\033[1;31m] \033[1;37m• \033[1;33mSSLH MULTIPLEX $sts7"
			echo -e "\033[1;31m[\033[1;36m00\033[1;31m] \033[1;37m• \033[1;33mSAIR \033[1;32m<\033[1;33m<\033[1;31m<\033[0m"
			echo ""
			echo -e "\033[0;34m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\033[0m"
			echo ""
			tput civis
			echo -ne "\033[1;32mOQUE DESEJA FAZER \033[1;33m?\033[1;31m?\033[1;37m "
			read x
			tput cnorm
			clear
			case $x in
			1 | 01) fun_openssh ;;
			2 | 02) fun_squid ;;
			3 | 03) fun_drop ;;
			4 | 04) fun_openvpn ;;
			5 | 05) fun_socks ;;
			6 | 06) inst_ssl ;;
			7 | 07) fun_sslh ;;
			0 | 00)
				echo -e "\033[1;31mSaindo...\033[0m"
				sleep 2
				clear
				exit
				;;
			*)
				echo -e "\033[1;31mOpcao invalida !\033[0m"
				sleep 2
				;;
			esac
		done
	}
	fun_conexao
}
