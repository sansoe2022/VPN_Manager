#!/bin/bash
#====================================================
#	@kiritosshxd - Ubuntu 22.04 Compatible Version
#====================================================

# Color definitions
cor1='\033[41;1;37m'
cor2='\033[44;1;37m'
scor='\033[0m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
RED='\033[1;31m'
BLUE='\033[1;36m'
SCOLOR='\033[0m'

# Check if script is run as root
[[ "$EUID" -ne 0 ]] && {
	echo -e "${RED}ဒီ script ကို root အနေနဲ့ run ပါ${SCOLOR}"
	exit 1
}

# Create necessary directories
mkdir -p /etc/SSHPlus
mkdir -p /home/sshplus

# Check license (simplified for testing)
[[ ! -f /usr/lib/licence ]] && echo "@KIRITO_SSH" > /usr/lib/licence

[[ $(awk -F" " '{print $2}' /usr/lib/licence 2>/dev/null) == "@KIRITO_SSH" ]] && {
	# System information
	ram1=$(free -h | grep -i mem | awk '{print $2}')
	ram2=$(free -h | grep -i mem | awk '{print $4}')
	ram3=$(free -h | grep -i mem | awk '{print $3}')
	uso=$(top -bn1 | awk '/Cpu/ { cpu = "" 100 - $8 "%" }; END { print cpu }')
	system=$(cat /etc/issue.net 2>/dev/null || echo "Ubuntu 22.04")

	# Progress bar function
	fun_bar() {
		comando[0]="$1"
		comando[1]="$2"
		(
			[[ -e $HOME/fim ]] && rm $HOME/fim
			${comando[0]} > /dev/null 2>&1
			${comando[1]} > /dev/null 2>&1
			touch $HOME/fim
		) > /dev/null 2>&1 &
		tput civis
		echo -ne "\033[1;33mစောင့်ပါ \033[1;37m- \033[1;33m["
		while true; do
			for ((i = 0; i < 18; i++)); do
				echo -ne "\033[1;31m#"
				sleep 0.1s
			done
			[[ -e $HOME/fim ]] && rm $HOME/fim && break
			echo -e "\033[1;33m]"
			sleep 1s
			tput cuu1
			tput dl1
			echo -ne "\033[1;33mစောင့်ပါ \033[1;37m- \033[1;33m["
		done
		echo -e "\033[1;33m]\033[1;37m -\033[1;32m OK !\033[1;37m"
		tput cnorm
	}

	# Port verification function
	verif_ptrs() {
		porta=$1
		PT=$(ss -tlnp 2>/dev/null | grep -v "State" | grep "LISTEN")
		for pton in $(echo -e "$PT" | awk '{print $4}' | cut -d: -f2 | sort -u); do
			svcs=$(echo -e "$PT" | grep ":$pton" | awk '{print $6}' | cut -d'"' -f2 | cut -d',' -f1 | sort -u)
			[[ "$porta" = "$pton" ]] && {
				echo -e "\n\033[1;31mပို့ \033[1;33m$porta \033[1;31mကို \033[1;37m$svcs \033[1;31mက အသုံးပြုနေပါတယ်\033[0m"
				sleep 3
				return 1
			}
		done
		return 0
	}

	# SlowDNS setup
	slow_setup() {
		if [[ -e "/bin/slowdns" ]]; then
			slowdns
		else
			cd $HOME
			wget -O install https://raw.githubusercontent.com/kiritosshxd/SSHPLUS/main/Slowdns/install 2>/dev/null
			chmod +x install
			./install
		fi
	}

	# Squid installation/management
	inst_sqd() {
		if ss -tlnp | grep -q 'squid'; then
			echo -e "\E[41;1;37m            SQUID PROXY ဖယ်ရှားရန်              \E[0m"
			echo ""
			echo -ne "\033[1;32mSQUID ကို ဖယ်ရှားမှာ သေချာပါသလား \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resp
			[[ "$resp" = 's' ]] && {
				echo -e "\n\033[1;32mSQUID PROXY ကို ဖယ်ရှားနေပါတယ် !\033[0m"
				echo ""
				rem_sqd() {
					systemctl stop squid 2>/dev/null
					apt-get remove squid -y > /dev/null 2>&1
					apt-get purge squid -y > /dev/null 2>&1
					rm -rf /etc/squid > /dev/null 2>&1
					apt autoremove -y > /dev/null 2>&1
				}
				fun_bar 'rem_sqd'
				echo -e "\n\033[1;32mSQUID ကို အောင်မြင်စွာ ဖယ်ရှားပြီးပါပြီ !\033[0m"
				sleep 2
				clear
				fun_conexao
			}
		else
			clear
			echo -e "\E[44;1;37m              SQUID ထည့်သွင်းရန်                \E[0m"
			echo ""
			IP=$(curl -s -4 ipinfo.io/ip || wget -qO- ipv4.icanhazip.com)
			echo -ne "\033[1;32mသင့် IP ကို အတည်ပြုပါ: \033[1;37m"
			read -e -i "$IP" ipdovps
			[[ -z "$ipdovps" ]] && {
				echo -e "\n\033[1;31mမမှန်ကန်သော IP\033[1;32m"
				sleep 2
				fun_conexao
			}
			echo -e "\n\033[1;33mSQUID အတွက် အသုံးပြုမည့် port များ \033[1;31m?"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mPort များကို အစီအစဉ်အလိုက် သတ်မှတ်ပါ \033[1;33mဥပမာ: \033[1;37m80 8080"
			echo ""
			echo -ne "\033[1;32mPort များကို ထည့်သွင်းပါ\033[1;37m: "
			read portass
			[[ -z "$portass" ]] && {
				echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
				sleep 3
				fun_conexao
			}
			for porta in $portass; do
				verif_ptrs "$porta" || fun_conexao
			done

			echo -e "\n\033[1;32mSQUID PROXY ကို ထည့်သွင်းနေပါတယ်\033[0m\n"
			fun_bar 'apt update -y' 'apt install squid -y'

			var_sqd="/etc/squid/squid.conf"
			var_pay="/etc/squid/payload.txt"

			cat > "$var_pay" <<-EOF
				.whatsapp.net/
				.facebook.net/
				.twitter.com/
				.speedtest.net/
			EOF

			cat > "$var_sqd" <<-EOF
				acl url1 dstdomain -i 127.0.0.1
				acl url2 dstdomain -i localhost
				acl url3 dstdomain -i $ipdovps
				acl url4 dstdomain -i /SSHPLUS?
				acl payload url_regex -i "$var_pay"
				acl all src 0.0.0.0/0

				http_access allow url1
				http_access allow url2
				http_access allow url3
				http_access allow url4
				http_access allow payload
				http_access deny all
				 
				#Portas
			EOF

			for Pts in $portass; do
				echo -e "http_port $Pts" >> "$var_sqd"
				ufw allow "$Pts/tcp" 2>/dev/null
			done

			cat >> "$var_sqd" <<-EOF
				#Nome squid
				visible_hostname SSHPLUS 
				via off
				forwarded_for off
				pipeline_prefetch off
			EOF

			sqd_conf() {
				systemctl restart ssh
				systemctl restart squid
				systemctl enable squid
			}

			echo -e "\n\033[1;32mSQUID PROXY ကို ပြင်ဆင်နေပါတယ်\033[0m"
			echo ""
			fun_bar 'sqd_conf'
			echo -e "\n\033[1;32mSQUID ကို အောင်မြင်စွာ ထည့်သွင်းပြီးပါပြီ!\033[0m"
			sleep 2
			fun_conexao
		fi
	}

	# Add port to Squid
	addpt_sqd() {
		echo -e "\E[44;1;37m         SQUID သို့ PORT ထည့်ရန်         \E[0m"
		if [[ -f "/etc/squid/squid.conf" ]]; then
			var_sqd="/etc/squid/squid.conf"
		else
			echo -e "\n\033[1;31mSQUID မထည့်သွင်းရသေးပါ!\033[0m"
			sleep 2
			fun_squid
			return
		fi

		sqdp=$(ss -tlnp | grep squid | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
		echo -e "\n\033[1;33mအသုံးပြုနေသော Ports: \033[1;32m$sqdp\n"
		echo -ne "\033[1;32mထည့်မည့် PORT \033[1;33m?\033[1;37m "
		read pt
		[[ -z "$pt" ]] && {
			echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
			sleep 2
			fun_squid
			return
		}

		verif_ptrs "$pt" || fun_squid

		echo -e "\n\033[1;32mSQUID သို့ PORT ထည့်နေပါတယ်!"
		sed -i "s/#Portas/#Portas\nhttp_port $pt/g" "$var_sqd"
		fun_bar 'sleep 2'
		echo -e "\n\033[1;32mSQUID ကို ပြန်လည်စတင်နေပါတယ်!"
		fun_bar 'systemctl restart squid'
		echo -e "\n\033[1;32mPORT ကို အောင်မြင်စွာ ထည့်ပြီးပါပြီ!"
		sleep 2
		fun_squid
	}

	# Remove port from Squid
	rempt_sqd() {
		echo -e "\E[41;1;37m        SQUID မှ PORT ဖယ်ရှားရန်        \E[0m"
		if [[ -f "/etc/squid/squid.conf" ]]; then
			var_sqd="/etc/squid/squid.conf"
		else
			echo -e "\n\033[1;31mSQUID မထည့်သွင်းရသေးပါ!\033[0m"
			sleep 2
			fun_squid
			return
		fi

		sqdp=$(ss -tlnp | grep squid | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
		echo -e "\n\033[1;33mအသုံးပြုနေသော Ports: \033[1;32m$sqdp\n"
		echo -ne "\033[1;32mဖယ်ရှားမည့် PORT \033[1;33m?\033[1;37m "
		read pt
		[[ -z "$pt" ]] && {
			echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
			sleep 2
			fun_squid
			return
		}

		if grep -q "http_port $pt" "$var_sqd"; then
			echo -e "\n\033[1;32mSQUID မှ PORT ဖယ်ရှားနေပါတယ်!"
			sed -i "/http_port $pt/d" "$var_sqd"
			fun_bar 'sleep 2'
			echo -e "\n\033[1;32mSQUID ကို ပြန်လည်စတင်နေပါတယ်!"
			fun_bar 'systemctl restart squid'
			echo -e "\n\033[1;32mPORT ကို အောင်မြင်စွာ ဖယ်ရှားပြီးပါပြီ!"
			sleep 2
			fun_squid
		else
			echo -e "\n\033[1;31mPORT \033[1;32m$pt \033[1;31mကို ရှာမတွေ့ပါ!"
			sleep 2
			fun_squid
		fi
	}

	# Squid management menu
	fun_squid() {
		[[ "$(ss -tlnp | grep -c 'squid')" = "0" ]] && inst_sqd
		echo -e "\E[44;1;37m          SQUID PROXY စီမံခန့်ခွဲမှု           \E[0m"
		
		if [[ "$(ss -tlnp | grep -c 'squid')" != "0" ]]; then
			sqdp=$(ss -tlnp | grep squid | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
			echo -e "\n\033[1;33mPORTS\033[1;37m: \033[1;32m$sqdp"
			VarSqdOn="SQUID PROXY ဖယ်ရှားရန်"
		else
			VarSqdOn="SQUID PROXY ထည့်သွင်းရန်"
		fi

		echo -e "\n\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33m$VarSqdOn \033[1;31m
[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mPORT ထည့်ရန် \033[1;31m
[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mPORT ဖယ်ရှားရန်\033[1;31m
[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
		echo ""
		echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
		read x
		clear
		case $x in
		1|01)
			inst_sqd
			;;
		2|02)
			addpt_sqd
			;;
		3|03)
			rempt_sqd
			;;
		0|00)
			echo -e "\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
			sleep 1
			fun_conexao
			;;
		*)
			echo -e "\033[1;31mမှားယွင်းသော ရွေးချယ်မှု...\033[0m"
			sleep 2
			fun_squid
			;;
		esac
	}

	# Dropbear management
	fun_drop() {
		if ss -tlnp | grep -q 'dropbear'; then
			clear
			dpbr=$(ss -tlnp | grep dropbear | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
			if pgrep -f "limiter" > /dev/null; then
				stats='\033[1;32m◉ '
			else
				stats='\033[1;31m○ '
			fi

			echo -e "\E[44;1;37m              DROPBEAR စီမံခန့်ခွဲမှု               \E[0m"
			echo -e "\n\033[1;33mPORTS\033[1;37m: \033[1;32m$dpbr"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mLIMITER DROPBEAR $stats\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mDROPBEAR PORT ပြောင်းရန်\033[0m"
			echo -e "\033[1;31m[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mDROPBEAR ဖယ်ရှားရန်\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
			echo ""
			echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
			read resposta

			case "$resposta" in
			1)
				clear
				if pgrep -f "limiter" > /dev/null; then
					echo -e "\033[1;32mLimiter ကို ရပ်နေပါတယ်... \033[0m"
					fun_stplimiter() {
						pkill -f limiter
						screen -wipe > /dev/null 2>&1
					}
					fun_bar 'fun_stplimiter' 'sleep 2'
					echo -e "\n\033[1;31m LIMITER ကို ပိတ်လိုက်ပါပြီ \033[0m"
					sleep 2
					fun_drop
				else
					echo -e "\n\033[1;32mLimiter ကို စတင်နေပါတယ်... \033[0m"
					fun_bar 'screen -dmS limiter droplimiter 2>/dev/null' 'sleep 3'
					echo -e "\n\033[1;32m  LIMITER ကို ဖွင့်လိုက်ပါပြီ \033[0m"
					sleep 2
					fun_drop
				fi
				;;
			2)
				echo ""
				echo -ne "\033[1;32mအသုံးပြုမည့် PORT \033[1;33m?\033[1;37m "
				read pt
				[[ -z "$pt" ]] && {
					echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
					sleep 2
					fun_drop
					return
				}
				verif_ptrs "$pt" || fun_drop
				
				echo -e "\n\033[1;32mDROPBEAR PORT ပြောင်းနေပါတယ်!"
				var1=$(grep 'DROPBEAR_PORT=' /etc/default/dropbear 2>/dev/null | cut -d'=' -f2)
				sed -i "s/DROPBEAR_PORT=$var1/DROPBEAR_PORT=$pt/g" /etc/default/dropbear 2>/dev/null
				fun_bar 'sleep 2'
				echo -e "\n\033[1;32mDROPBEAR ကို ပြန်လည်စတင်နေပါတယ်!"
				fun_bar 'systemctl restart dropbear' 'sleep 2'
				echo -e "\n\033[1;32mPORT ကို အောင်မြင်စွာ ပြောင်းပြီးပါပြီ!"
				sleep 2
				fun_conexao
				;;
			3)
				echo -e "\n\033[1;32mDROPBEAR ကို ဖယ်ရှားနေပါတယ် !\033[0m"
				fun_dropuninstall() {
					systemctl stop dropbear 2>/dev/null
					apt-get autoremove dropbear -y > /dev/null 2>&1
					apt-get remove dropbear -y > /dev/null 2>&1
					apt-get purge dropbear -y > /dev/null 2>&1
					rm -rf /etc/default/dropbear
				}
				fun_bar 'fun_dropuninstall'
				echo -e "\n\033[1;32mDROPBEAR ကို အောင်မြင်စွာ ဖယ်ရှားပြီးပါပြီ !\033[0m"
				sleep 2
				fun_conexao
				;;
			0)
				echo -e "\n\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
				sleep 1
				fun_conexao
				;;
			*)
				echo -e "\n\033[1;31mမှားယွင်းသော ရွေးချယ်မှု...\033[0m"
				sleep 1
				fun_drop
				;;
			esac
		else
			clear
			echo -e "\E[44;1;37m           DROPBEAR ထည့်သွင်းရန်              \E[0m"
			echo -e "\n\033[1;33mDROPBEAR ကို ထည့်သွင်းမှာလား !\033[0m\n"
			echo -ne "\033[1;32mဆက်လုပ်မှာလား \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resposta
			[[ "$resposta" = 's' ]] && {
				echo -e "\n\033[1;33mDROPBEAR အတွက် PORT သတ်မှတ်ပါ !\033[0m\n"
				echo -ne "\033[1;32mPORT \033[1;33m?\033[1;37m "
				read porta
				[[ -z "$porta" ]] && {
					echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
					sleep 2
					fun_conexao
					return
				}
				verif_ptrs "$porta" || fun_conexao

				echo -e "\n\033[1;32mDROPBEAR ကို ထည့်သွင်းနေပါတယ် ! \033[0m"
				fun_instdrop() {
					apt-get update -y > /dev/null 2>&1
					apt-get install dropbear -y > /dev/null 2>&1
				}
				fun_bar 'fun_instdrop'

				fun_ports() {
					sed -i 's/NO_START=1/NO_START=0/g' /etc/default/dropbear 2>/dev/null
					sed -i "s/DROPBEAR_PORT=22/DROPBEAR_PORT=$porta/g" /etc/default/dropbear 2>/dev/null
					sed -i 's/DROPBEAR_EXTRA_ARGS=/DROPBEAR_EXTRA_ARGS="-p 110"/g' /etc/default/dropbear 2>/dev/null
				}
				echo ""
				echo -e "\033[1;32mDROPBEAR PORT ပြင်ဆင်နေပါတယ် !\033[0m"
				fun_bar 'fun_ports'

				grep -v "^PasswordAuthentication yes" /etc/ssh/sshd_config > /tmp/passlogin 2>/dev/null && mv /tmp/passlogin /etc/ssh/sshd_config
				echo "PasswordAuthentication yes" >> /etc/ssh/sshd_config
				grep -v "^PermitTunnel yes" /etc/ssh/sshd_config > /tmp/ssh 2>/dev/null && mv /tmp/ssh /etc/ssh/sshd_config
				echo "PermitTunnel yes" >> /etc/ssh/sshd_config

				echo ""
				echo -e "\033[1;32mထည့်သွင်းမှု ပြီးဆုံးနေပါပြီ !\033[0m"
				fun_ondrop() {
					systemctl start dropbear
					systemctl enable dropbear
					systemctl restart dropbear
				}
				fun_bar 'fun_ondrop' 'sleep 1'
				echo -e "\n\033[1;32mထည့်သွင်းမှု ပြီးပါပြီ \033[1;33mPORT: \033[1;37m$porta\033[0m"
				[[ $(grep -c "/bin/false" /etc/shells) = '0' ]] && echo "/bin/false" >> /etc/shells
				sleep 2
				fun_conexao
			} || {
				echo ""
				echo -e "\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
				sleep 2
				fun_conexao
			}
		fi
	}

	# V2Ray installation
	fun_v2rayins() {
		clear
		v2rayinst() {
			bash <(curl -sL https://raw.githubusercontent.com/kiritosshxd/SSHPLUS/main/Modulos/v2ray) 2>/dev/null
			sleep 3
		}

		if ss -tunlp | grep -q v2ray; then
			echo -e "\E[44;1;37m            V2RAY ထည့်သွင်းရန်             \E[0m"
			echo -e "\n${YELLOW}V2RAY ထည့်သွင်းပြီးသားပါ\nပြန်လည်ထည့်သွင်းမှာလား? ${SCOLOR}\n"
			echo -ne "${GREEN}ဆက်လုပ်မှာလား ? ${YELLOW}[s/n]:${SCOLOR} "
			read resp
			[[ "$resp" != "s" ]] && {
				echo -e "\n${RED}ပြန်သွားနေပါတယ်...${SCOLOR}"
				sleep 1
				fun_conexao
				return
			}
			v2rayinst
		else
			echo -e "\E[44;1;37m            V2RAY ထည့်သွင်းရန်             \E[0m"
			echo -e "\n${YELLOW}ဒီနည်းလမ်းက မတည်ငြိမ်ပါဘူး\nအန္တရာယ်များကို သတိပြုပါ ! ${SCOLOR}\n"
			echo -ne "${GREEN}ဆက်လုပ်မှာလား ? ${YELLOW}[s/n]:${SCOLOR} "
			read resp
			[[ "$resp" != "s" ]] && {
				echo -e "\n${RED}ပြန်သွားနေပါတယ်...${SCOLOR}"
				sleep 1
				fun_conexao
				return
			}
			v2rayinst
		fi
	}

	# Chisel management
	fun_chisel() {
		clear
		echo -e "\E[44;1;37m            CHISEL စီမံခန့်ခွဲမှု             \E[0m"
		echo ""

		if [[ "$(ss -tlpn | grep 'docker' | wc -l)" != '0' ]]; then
			sks='\033[1;32mON'
			chisel_ports=$(ss -tlnp | grep 'docker' | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
			echo -e "\033[1;33mPORTS\033[1;37m: \033[1;32m$chisel_ports"
			chiselsts="\033[1;32m◉ "
		else
			sks='\033[1;31mOFF'
			chiselsts="\033[1;31m○ "
		fi

		echo ""
		echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mCHISEL ဖွင့်/ပိတ် $chiselsts \033[0m"
		echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mCHISEL ပြန်လည်စတင်ရန်\033[0m"
		echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
		echo ""
		echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
		read resposta

		case "$resposta" in
		1)
			if ss -tlnp | grep -q 'docker'; then
				clear
				echo -e "\E[41;1;37m             CHISEL              \E[0m"
				echo ""
				fun_chiseloff() {
					docker stop chisel 2>/dev/null
					docker rm chisel 2>/dev/null
				}
				echo -e "\033[1;32mCHISEL ကို ပိတ်နေပါတယ်\033[1;33m"
				echo ""
				fun_bar 'fun_chiseloff'
				echo ""
				echo -e "\033[1;32mCHISEL ကို အောင်မြင်စွာ ပိတ်လိုက်ပါပြီ!\033[1;33m"
				sleep 2
				fun_chisel
			else
				clear
				
				# Check if docker is installed
				if ! command -v docker &> /dev/null; then
					echo -e "\n${YELLOW}ဒီနည်းလမ်းက မတည်ငြိမ်ပါဘူး\nအလုပ်မလုပ်နိုင်ပါ\nအန္တရာယ်များကို သတိပြုပါ ! ${SCOLOR}\n"
					echo -ne "${GREEN}ဆက်လုပ်မှာလား ? ${YELLOW}[s/n]:${SCOLOR} "
					read resp
					[[ "$resp" != "s" ]] && {
						echo -e "\n${RED}ပြန်သွားနေပါတယ်...${SCOLOR}"
						sleep 1
						fun_conexao
						return
					}

					echo -e "\n\033[1;32mUbuntu 16+ အတွက် ပံ့ပိုးပါတယ်\033[1;33m"
					echo -e "\n\033[1;32mDOCKER ကို ထည့်သွင်းနေပါတယ် !\033[1;33m"
					echo ""
					
					fun_installdocker() {
						apt-get update -y > /dev/null 2>&1
						apt-get install -y docker.io > /dev/null 2>&1
						systemctl start docker > /dev/null 2>&1
						systemctl enable docker > /dev/null 2>&1
					}
					fun_bar 'fun_installdocker'
				fi

				clear
				echo -e "\E[44;1;37m             CHISEL              \E[0m"
				echo ""
				echo -ne "\033[1;32mအသုံးပြုမည့် PORT \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mမမှန်ကန်သော Port!"
					sleep 2
					fun_chisel
					return
				}
				verif_ptrs "$porta" || fun_chisel

				clear
				echo -ne "\033[1;32mအသုံးပြုသူအမည်:\033[1;37m "
				read username
				[[ -z "$username" ]] && {
					echo -e "\n${cor1}အသုံးပြုသူအမည် မရှိပါ!${scor}\n"
					fun_chisel
					return
				}

				echo -ne "\033[1;32mစကားဝှက်:\033[1;37m "
				read password
				[[ -z "$password" ]] && {
					echo -e "\n${cor1}စကားဝှက် မရှိပါ!${scor}\n"
					fun_chisel
					return
				}

				echo -e "\n\033[1;32mCHISEL ကို ပြင်ဆင်နေပါတယ် !\033[0m"
				echo ""
				fun_inichisel() {
					docker run --name chisel -p "$porta:$porta" -d --restart always jpillora/chisel server -p "$porta" --socks5 --key supersecret --auth "$username:$password" > /dev/null 2>&1
				}
				fun_bar 'fun_inichisel'
				clear
				echo -e "\n\033[1;32mCHISEL ကို အောင်မြင်စွာ ထည့်သွင်းပြီးပါပြီ !\033[1;31m PORT: \033[1;33m${porta}\033[0m"
				sleep 2
				fun_chisel
			fi
			;;
		2)
			clear
			echo -e "\n\033[1;32mCHISEL ကို ပြန်လည်စတင်နေပါတယ် !\033[1;33m"
			echo ""
			fun_attchisel() {
				docker restart chisel 2>/dev/null
			}
			fun_bar 'fun_attchisel'
			clear
			echo -e "\n\033[1;32mCHISEL ကို အောင်မြင်စွာ ပြန်လည်စတင်ပြီးပါပြီ !\033[1;33m"
			sleep 2
			fun_chisel
			;;
		0)
			echo ""
			echo -e "\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
			sleep 1
			fun_conexao
			;;
		*)
			echo ""
			echo -e "\033[1;31mမှားယွင်းသော ရွေးချယ်မှု !\033[0m"
			sleep 1
			fun_chisel
			;;
		esac
	}

	# SSL Tunnel installation
	inst_ssl() {
		if ss -tlnp | grep -q 'stunnel'; then
			sslt=$(ss -tlnp | grep stunnel | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
			echo -e "\E[44;1;37m              SSL TUNNEL စီမံခန့်ခွဲမှု               \E[0m"
			echo -e "\n\033[1;33mPORTS\033[1;37m: \033[1;32m$sslt"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mSSL TUNNEL PORT ပြောင်းရန်\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mSSL TUNNEL ဖယ်ရှားရန်\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
			echo ""
			echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
			read resposta
			echo ""

			case "$resposta" in
			1)
				echo -ne "\033[1;32mအသုံးပြုမည့် PORT \033[1;33m?\033[1;37m "
				read porta
				[[ -z "$porta" ]] && {
					echo -e "\033[1;31mမမှန်ကန်သော Port!"
					sleep 2
					fun_conexao
					return
				}
				verif_ptrs "$porta" || fun_conexao

				echo -e "\033[1;32mSSL TUNNEL PORT ပြောင်းနေပါတယ်!"
				var2=$(grep 'accept' /etc/stunnel/stunnel.conf | awk '{print $NF}')
				sed -i "s/\b$var2\b/$porta/g" /etc/stunnel/stunnel.conf 2>/dev/null
				echo ""
				fun_bar 'sleep 2'
				echo ""
				echo -e "\033[1;32mSSL TUNNEL ကို ပြန်လည်စတင်နေပါတယ်!\n"
				fun_bar 'systemctl restart stunnel4'
				echo ""
				ss -tlnp | grep -q 'stunnel' && echo -e "\033[1;32mPORT ကို အောင်မြင်စွာ ပြောင်းပြီးပါပြီ !" || echo -e "\033[1;31mမမျှော်လင့်သော အမှား!"
				sleep 2
				fun_conexao
				;;
			2)
				echo -e "\033[1;32mSSL TUNNEL ကို ဖယ်ရှားနေပါတယ် !\033[0m"
				del_ssl() {
					systemctl stop stunnel4 2>/dev/null
					apt-get remove stunnel4 -y > /dev/null 2>&1
					apt-get autoremove stunnel4 -y > /dev/null 2>&1
					apt-get purge stunnel4 -y > /dev/null 2>&1
					rm -rf /etc/stunnel/stunnel.conf
					rm -rf /etc/default/stunnel4
					rm -rf /etc/stunnel/cert.pem
					rm -rf /etc/stunnel/key.pem
				}
				echo ""
				fun_bar 'del_ssl'
				echo ""
				echo -e "\033[1;32mSSL TUNNEL ကို အောင်မြင်စွာ ဖယ်ရှားပြီးပါပြီ!\033[0m"
				sleep 2
				fun_conexao
				;;
			0)
				echo -e "\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
				sleep 2
				fun_conexao
				;;
			*)
				echo -e "\033[1;31mမှားယွင်းသော ရွေးချယ်မှု!\033[0m"
				sleep 2
				inst_ssl
				;;
			esac
		else
			clear
			echo -e "\E[44;1;37m              SSL TUNNEL ထည့်သွင်းရန်               \E[0m"
			echo ""
			echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mSSL TUNNEL စံ\033[0m"
			echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mSSL TUNNEL WEBSOCKET\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
			echo ""
			echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
			read resposta
			echo ""

			case "$resposta" in
			1)
				portssl='22'
				;;
			2)
				portssl='80'
				;;
			0)
				echo -e "\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
				sleep 2
				fun_conexao
				return
				;;
			*)
				echo -e "\033[1;31mမှားယွင်းသော ရွေးချယ်မှု !\033[0m"
				sleep 1
				inst_ssl
				return
				;;
			esac

			clear
			echo -e "\E[44;1;37m           SSL TUNNEL ထည့်သွင်းရန်             \E[0m"
			echo -e "\n\033[1;33mSSL TUNNEL ကို ထည့်သွင်းမှာလား !\033[0m"
			echo ""
			echo -ne "\033[1;32mဆက်လုပ်မှာလား \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resposta
			[[ "$resposta" = 's' ]] && {
				echo -e "\n\033[1;33mSSL TUNNEL အတွက် PORT သတ်မှတ်ပါ !\033[0m"
				echo ""
				read -p "$(echo -e "\033[1;32mPORT? \033[1;37m")" -e -i 443 porta
				[[ -z "$porta" ]] && {
					echo ""
					echo -e "\033[1;31mမမှန်ကန်သော Port!"
					sleep 2
					fun_conexao
					return
				}
				verif_ptrs "$porta" || fun_conexao

				echo -e "\n\033[1;32mSSL TUNNEL ကို ထည့်သွင်းနေပါတယ် !\033[1;33m"
				echo ""
				fun_bar 'apt-get update -y' 'apt-get install stunnel4 -y'

				echo -e "\n\033[1;32mSSL TUNNEL ကို ပြင်ဆင်နေပါတယ် !\033[0m"
				echo ""
				ssl_conf() {
					cat > /etc/stunnel/stunnel.conf <<-EOF
						cert = /etc/stunnel/stunnel.pem
						client = no
						socket = a:SO_REUSEADDR=1
						socket = l:TCP_NODELAY=1
						socket = r:TCP_NODELAY=1

						[stunnel]
						connect = 127.0.0.1:${portssl}
						accept = ${porta}
					EOF
				}
				fun_bar 'ssl_conf'

				echo -e "\n\033[1;32mလက်မှတ်ထုတ်နေပါတယ် !\033[0m"
				echo ""
				ssl_certif() {
					openssl genrsa -out /tmp/key.pem 2048 > /dev/null 2>&1
					openssl req -new -x509 -key /tmp/key.pem -out /tmp/cert.pem -days 1095 -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost" > /dev/null 2>&1
					cat /tmp/cert.pem /tmp/key.pem > /etc/stunnel/stunnel.pem
					rm -f /tmp/key.pem /tmp/cert.pem
					sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4 2>/dev/null
				}
				fun_bar 'ssl_certif'

				echo -e "\n\033[1;32mSSL TUNNEL ကို စတင်နေပါတယ် !\033[0m"
				echo ""
				fun_finssl() {
					systemctl restart stunnel4
					systemctl enable stunnel4
					systemctl restart ssh
				}
				fun_bar 'fun_finssl'
				
				echo -e "\n\033[1;32mSSL TUNNEL ကို အောင်မြင်စွာ ထည့်သွင်းပြီးပါပြီ !\033[1;31m PORT: \033[1;33m$porta\033[0m"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
				sleep 2
				fun_conexao
			}
		fi
	}

	# OpenVPN installation (simplified for Ubuntu 22.04)
	fun_openvpn() {
		if ss -tlnp | grep -q 'openvpn'; then
			echo -e "\E[44;1;37m          OPENVPN စီမံခန့်ခွဲမှု           \E[0m"
			echo -e "\n\033[1;33mOPENVPN ထည့်သွင်းပြီးသားပါ\033[0m"
			echo -e "\n\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mOPENVPN ဖယ်ရှားရန်\033[0m"
			echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
			echo ""
			echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
			read option
			
			case "$option" in
			1)
				echo -e "\n\033[1;32mOPENVPN ကို ဖယ်ရှားနေပါတယ် !\033[0m"
				rmv_open() {
					systemctl stop openvpn 2>/dev/null
					apt-get remove --purge -y openvpn > /dev/null 2>&1
					apt-get autoremove -y > /dev/null 2>&1
					rm -rf /etc/openvpn
				}
				fun_bar 'rmv_open'
				echo -e "\n\033[1;32mOPENVPN ကို အောင်မြင်စွာ ဖယ်ရှားပြီးပါပြီ!\033[0m"
				sleep 2
				fun_conexao
				;;
			0)
				fun_conexao
				;;
			*)
				echo -e "\033[1;31mမှားယွင်းသော ရွေးချယ်မှု!\033[0m"
				sleep 1
				fun_openvpn
				;;
			esac
		else
			clear
			echo -e "\E[44;1;37m              OPENVPN ထည့်သွင်းရန်               \E[0m"
			echo ""
			echo -e "\033[1;33mသတိပေးချက်: OPENVPN ထည့်သွင်းမှုက ရှုပ်ထွေးပါတယ်\033[0m"
			echo -e "\033[1;33mUbuntu 22.04 အတွက် အခြေခံ ထည့်သွင်းမှု ပဲ လုပ်ပေးပါမယ်\033[0m\n"
			echo -ne "\033[1;32mဆက်လုပ်မှာလား \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resp
			[[ "$resp" != "s" ]] && {
				echo -e "\n\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
				sleep 2
				fun_conexao
				return
			}

			echo -e "\n\033[1;32mOPENVPN ကို ထည့်သွင်းနေပါတယ်...\033[0m"
			fun_bar 'apt-get update -y' 'apt-get install openvpn easy-rsa -y'
			echo -e "\n\033[1;32mOPENVPN အခြေခံ ထည့်သွင်းပြီးပါပြီ\033[0m"
			echo -e "\033[1;33mပြီးပြည့်စုံသော ပြင်ဆင်မှုအတွက် တခြား script များ လိုအပ်ပါတယ်\033[0m"
			sleep 3
			fun_conexao
		fi
	}

	# Proxy SOCKS management
	fun_socks() {
		clear
		echo -e "\E[44;1;37m            PROXY SOCKS စီမံခန့်ခွဲမှု             \E[0m"
		echo ""

		if [[ $(pgrep -f "proxy.py" | wc -l) != '0' ]]; then
			sks='\033[1;32mON'
			socks_ports=$(ss -tlnp | grep python | awk '{print $4}' | cut -d: -f2 | sort -u | xargs 2>/dev/null)
			[[ -n "$socks_ports" ]] && echo -e "\033[1;33mPORTS\033[1;37m: \033[1;32m$socks_ports"
		else
			sks='\033[1;31mOFF'
		fi

		[[ $(screen -list 2>/dev/null | grep -wc 'proxy') != '0' ]] && var_sks1="\033[1;32m◉" || var_sks1="\033[1;31m○"
		[[ $(screen -list 2>/dev/null | grep -wc 'ws') != '0' ]] && var_sks2="\033[1;32m◉" || var_sks2="\033[1;31m○"

		echo ""
		echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mSOCKS SSH $var_sks1 \033[0m"
		echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mWEBSOCKET $var_sks2 \033[0m"
		echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
		echo ""
		echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
		read resposta

		case "$resposta" in
		1)
			if pgrep -f "proxy.py" > /dev/null; then
				clear
				echo -e "\E[41;1;37m             PROXY SOCKS              \E[0m"
				echo ""
				fun_socksoff() {
					for pidproxy in $(screen -ls 2>/dev/null | grep ".proxy" | awk '{print $1}'); do
						screen -S "$pidproxy" -X quit 2>/dev/null
					done
					screen -wipe > /dev/null 2>&1
				}
				echo -e "\033[1;32mPROXY SOCKS ကို ပိတ်နေပါတယ်\033[1;33m"
				fun_bar 'fun_socksoff'
				echo ""
				echo -e "\033[1;32mPROXY SOCKS ကို အောင်မြင်စွာ ပိတ်လိုက်ပါပြီ!\033[1;33m"
				sleep 2
				fun_socks
			else
				# Create proxy.py script if it doesn't exist
				if [[ ! -f "/etc/SSHPlus/proxy.py" ]]; then
					mkdir -p /etc/SSHPlus
					cat > /etc/SSHPlus/proxy.py <<-'EOF'
#!/usr/bin/env python3
import socket, threading, sys, time

MSG = "SSH/SOCKS"
PASS = ''
BUFLEN = 8196
TIMEOUT = 60

class Server(threading.Thread):
    def __init__(self, host, port):
        threading.Thread.__init__(self)
        self.running = False
        self.host = host
        self.port = port
        self.threads = []
        
    def run(self):
        self.soc = socket.socket(socket.AF_INET)
        self.soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.soc.settimeout(2)
        self.soc.bind((self.host, self.port))
        self.soc.listen(0)
        self.running = True
        
        try:
            while self.running:
                try:
                    c, addr = self.soc.accept()
                    c.setblocking(1)
                except socket.timeout:
                    continue
                
                conn = ConnectionHandler(c, self, addr)
                conn.start()
                self.threads.append(conn)
        finally:
            self.running = False
            self.soc.close()

class ConnectionHandler(threading.Thread):
    def __init__(self, socClient, server, addr):
        threading.Thread.__init__(self)
        self.clientClosed = False
        self.targetClosed = True
        self.client = socClient
        self.client_buffer = ''
        self.server = server
        self.log = 'Connection: ' + str(addr)

    def run(self):
        try:
            self.client_buffer = self.client.recv(BUFLEN)
            
            hostPort = self.findHeader(self.client_buffer, 'X-Real-Host')
            
            if hostPort == '':
                hostPort = '127.0.0.1:22'
            
            split = self.findHeader(self.client_buffer, 'X-Split')
            
            if split != '':
                self.client.recv(BUFLEN)
            
            if hostPort != '':
                passwd = self.findHeader(self.client_buffer, 'X-Pass')
                
                if len(PASS) != 0 and passwd == PASS:
                    self.method_CONNECT(hostPort)
                elif len(PASS) != 0 and passwd != PASS:
                    self.client.send(b'HTTP/1.1 400 WrongPass!\r\n\r\n')
                elif hostPort.startswith('127.0.0.1') or hostPort.startswith('localhost'):
                    self.method_CONNECT(hostPort)
                else:
                    self.client.send(b'HTTP/1.1 403 Forbidden!\r\n\r\n')
            else:
                self.client.send(b'HTTP/1.1 400 BadRequest!\r\n\r\n')
        except Exception as e:
            self.log += ' - error: ' + str(e)
            self.client.close()
        
    def findHeader(self, head, header):
        aux = head.find(bytes(header, 'utf-8') + b': ')
        
        if aux == -1:
            return ''
        
        aux = head.find(b': ', aux)
        head = head[aux+2:]
        aux = head.find(b'\r\n')
        
        if aux == -1:
            return ''
        
        return head[:aux].decode('utf-8')

    def method_CONNECT(self, path):
        self.log += ' - CONNECT ' + path
        
        self.target = socket.socket(socket.AF_INET)
        self.target.settimeout(TIMEOUT)
        
        try:
            host, port = path.split(':')
            self.target.connect((host, int(port)))
            
            self.client.send(b'HTTP/1.1 200 ' + bytes(MSG, 'utf-8') + b'\r\n\r\n')
            self.targetClosed = False
            self.client_buffer = ''
            
            self.doCONNECT()
        except Exception as e:
            self.log += ' - error: ' + str(e)
            self.client.send(b'HTTP/1.1 502 BadGateway\r\n\r\n')

    def doCONNECT(self):
        socs = [self.client, self.target]
        count = 0
        
        while True:
            count += 1
            recv, _, err = select.select(socs, [], socs, 3)
            
            if err:
                break
            
            if recv:
                for in_ in recv:
                    try:
                        data = in_.recv(BUFLEN)
                        
                        if not data:
                            break
                        
                        if in_ is self.target:
                            self.client.send(data)
                        else:
                            while data:
                                byte = self.target.send(data)
                                data = data[byte:]
                        
                        count = 0
                    except:
                        break
            
            if count == TIMEOUT:
                break
        
        self.close()

    def close(self):
        try:
            if not self.clientClosed:
                self.client.close()
                self.clientClosed = True
            
            if not self.targetClosed:
                self.target.close()
                self.targetClosed = True
        except:
            pass

def main(host, port):
    print(f"\033[1;32mSOCKS Proxy starting on {host}:{port}\033[0m")
    server = Server(host, int(port))
    server.start()
    
    while True:
        try:
            time.sleep(1)
        except KeyboardInterrupt:
            print('\nStopping...')
            server.running = False
            break

if __name__ == '__main__':
    import select
    if len(sys.argv) < 2:
        print('Usage: python proxy.py <port>')
        sys.exit(1)
    main('0.0.0.0', sys.argv[1])
EOF
					chmod +x /etc/SSHPlus/proxy.py
				fi

				clear
				echo -e "\E[44;1;37m             PROXY SOCKS              \E[0m"
				echo ""
				echo -ne "\033[1;32mအသုံးပြုမည့် PORT \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
					sleep 2
					fun_socks
					return
				}
				verif_ptrs "$porta" || fun_socks

				fun_inisocks() {
					screen -dmS proxy python3 /etc/SSHPlus/proxy.py "$porta"
					sleep 1
				}
				echo ""
				echo -e "\033[1;32mPROXY SOCKS ကို စတင်နေပါတယ်\033[1;33m"
				echo ""
				fun_bar 'fun_inisocks'
				echo ""
				echo -e "\033[1;32mSOCKS ကို အောင်မြင်စွာ ဖွင့်လိုက်ပါပြီ\033[1;33m"
				sleep 2
				fun_socks
			fi
			;;
		2)
			if pgrep -f "wsproxy.py" > /dev/null; then
				clear
				echo -e "\E[41;1;37m             WEBSOCKET              \E[0m"
				echo ""
				fun_wssocksoff() {
					for pidproxy in $(screen -ls 2>/dev/null | grep ".ws" | awk '{print $1}'); do
						screen -S "$pidproxy" -X quit 2>/dev/null
					done
					screen -wipe > /dev/null 2>&1
				}
				echo -e "\033[1;32mWEBSOCKET ကို ပိတ်နေပါတယ်\033[1;33m"
				fun_bar 'fun_wssocksoff'
				echo ""
				echo -e "\033[1;32mWEBSOCKET ကို အောင်မြင်စွာ ပိတ်လိုက်ပါပြီ!\033[1;33m"
				sleep 2
				fun_socks
			else
				# Create wsproxy.py if it doesn't exist
				if [[ ! -f "/etc/SSHPlus/wsproxy.py" ]]; then
					mkdir -p /etc/SSHPlus
					cat > /etc/SSHPlus/wsproxy.py <<-'EOF'
#!/usr/bin/env python3
import socket, threading, sys, time, base64, hashlib

MSG = "SSH/WS"

class WebSocketProxy(threading.Thread):
    def __init__(self, host, port):
        threading.Thread.__init__(self)
        self.host = host
        self.port = port
        self.running = False
        
    def run(self):
        self.soc = socket.socket(socket.AF_INET)
        self.soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.soc.bind((self.host, self.port))
        self.soc.listen(5)
        self.running = True
        
        print(f"\033[1;32mWebSocket Proxy running on {self.host}:{self.port}\033[0m")
        
        while self.running:
            try:
                client, addr = self.soc.accept()
                threading.Thread(target=self.handle_client, args=(client,)).start()
            except:
                pass
    
    def handle_client(self, client):
        try:
            data = client.recv(4096)
            if b'Upgrade: websocket' in data:
                key = None
                for line in data.split(b'\r\n'):
                    if b'Sec-WebSocket-Key:' in line:
                        key = line.split(b': ')[1]
                        break
                
                if key:
                    accept = base64.b64encode(
                        hashlib.sha1(key + b'258EAFA5-E914-47DA-95CA-C5AB0DC85B11').digest()
                    )
                    
                    response = (
                        b'HTTP/1.1 101 Switching Protocols\r\n'
                        b'Upgrade: websocket\r\n'
                        b'Connection: Upgrade\r\n'
                        b'Sec-WebSocket-Accept: ' + accept + b'\r\n\r\n'
                    )
                    client.send(response)
                    
                    target = socket.socket(socket.AF_INET)
                    target.connect(('127.0.0.1', 22))
                    
                    self.forward(client, target)
            else:
                client.close()
        except Exception as e:
            client.close()
    
    def forward(self, client, target):
        import select
        socs = [client, target]
        
        while True:
            recv, _, err = select.select(socs, [], socs, 3)
            
            if err:
                break
            
            if recv:
                for sock in recv:
                    try:
                        data = sock.recv(8192)
                        if not data:
                            return
                        
                        if sock is client:
                            target.send(data)
                        else:
                            client.send(data)
                    except:
                        return

def main(port):
    proxy = WebSocketProxy('0.0.0.0', int(port))
    proxy.start()
    
    while True:
        try:
            time.sleep(1)
        except KeyboardInterrupt:
            print('\nStopping...')
            proxy.running = False
            break

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print('Usage: python wsproxy.py <port>')
        sys.exit(1)
    main(sys.argv[1])
EOF
					chmod +x /etc/SSHPlus/wsproxy.py
				fi

				clear
				echo -e "\E[44;1;37m             WEBSOCKET              \E[0m"
				echo ""
				echo -ne "\033[1;32mအသုံးပြုမည့် PORT \033[1;33m?\033[1;37m: "
				read porta
				[[ -z "$porta" ]] && {
					echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
					sleep 2
					fun_socks
					return
				}
				verif_ptrs "$porta" || fun_socks

				fun_iniwssocks() {
					screen -dmS ws python3 /etc/SSHPlus/wsproxy.py "$porta"
					sleep 1
				}
				echo ""
				echo -e "\033[1;32mWEBSOCKET ကို စတင်နေပါတယ်\033[1;33m"
				echo ""
				fun_bar 'fun_iniwssocks'
				echo ""
				echo -e "\033[1;32mWEBSOCKET ကို အောင်မြင်စွာ ဖွင့်လိုက်ပါပြီ\033[1;33m"
				sleep 2
				fun_socks
			fi
			;;
		0)
			echo ""
			echo -e "\033[1;31mပြန်သွားနေပါတယ်...\033[0m"
			sleep 1
			fun_conexao
			;;
		*)
			echo ""
			echo -e "\033[1;31mမှားယွင်းသော ရွေးချယ်မှု !\033[0m"
			sleep 1
			fun_socks
			;;
		esac
	}

	# OpenSSH management
	fun_openssh() {
		clear
		echo -e "\E[44;1;37m            OPENSSH             \E[0m\n"
		echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mPORT ထည့်ရန်\033[1;31m
[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mPORT ဖယ်ရှားရန်\033[1;31m
[\033[1;36m3\033[1;31m] \033[1;37m• \033[1;33mပြန်သွားမည်\033[0m"
		echo ""
		echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
		read resp

		case "$resp" in
		1)
			clear
			echo -e "\E[44;1;37m         SSH သို့ PORT ထည့်ရန်         \E[0m\n"
			echo -ne "\033[1;32mထည့်မည့် PORT \033[1;33m?\033[1;37m "
			read pt
			[[ -z "$pt" ]] && {
				echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
				sleep 2
				fun_openssh
				return
			}
			verif_ptrs "$pt" || fun_openssh

			echo -e "\n\033[1;32mSSH သို့ PORT ထည့်နေပါတယ်\033[0m"
			echo ""
			fun_addpssh() {
				echo "Port $pt" >> /etc/ssh/sshd_config
				systemctl restart ssh
			}
			fun_bar 'fun_addpssh'
			echo -e "\n\033[1;32mPORT ကို အောင်မြင်စွာ ထည့်ပြီးပါပြီ\033[0m"
			sleep 2
			fun_openssh
			;;
		2)
			clear
			echo -e "\E[41;1;37m         SSH မှ PORT ဖယ်ရှားရန်         \E[0m"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mစံ PORT \033[1;37m22 \033[1;33mသတိပြုပါ !\033[0m"
			current_ports=$(grep '^Port' /etc/ssh/sshd_config | cut -d' ' -f2 | xargs)
			echo -e "\n\033[1;33mအသုံးပြုနေသော Ports: \033[1;37m$current_ports\n"
			echo -ne "\033[1;32mဖယ်ရှားမည့် PORT \033[1;33m?\033[1;37m "
			read pt
			[[ -z "$pt" ]] && {
				echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
				sleep 2
				fun_openssh
				return
			}

			if grep -q "^Port $pt" /etc/ssh/sshd_config; then
				echo -e "\n\033[1;32mSSH မှ PORT ဖယ်ရှားနေပါတယ်\033[0m"
				echo ""
				fun_delpssh() {
					sed -i "/^Port $pt/d" /etc/ssh/sshd_config
					systemctl restart ssh
				}
				fun_bar 'fun_delpssh'
				echo -e "\n\033[1;32mPORT ကို အောင်မြင်စွာ ဖယ်ရှားပြီးပါပြီ\033[0m"
				sleep 2
				fun_openssh
			else
				echo -e "\n\033[1;31mမမှန်ကန်သော Port!"
				sleep 2
				fun_openssh
			fi
			;;
		3)
			echo -e "\n\033[1;31mပြန်သွားနေပါတယ်..\033[0m"
			sleep 1
			fun_conexao
			;;
		*)
			echo -e "\n\033[1;31mမှားယွင်းသော ရွေးချယ်မှု!\033[0m"
			sleep 1
			fun_openssh
			;;
		esac
	}

	# SSLH management
	fun_sslh() {
		if ! ss -tlnp | grep -q 'sslh'; then
			clear
			echo -e "\E[44;1;37m             SSLH ထည့်သွင်းရန်               \E[0m\n"
			echo -e "\n\033[1;33m[\033[1;31m!\033[1;33m] \033[1;32mPORT \033[1;37m443 \033[1;32mကို စံအတိုင်း အသုံးပြုပါမယ်\033[0m\n"
			echo -ne "\033[1;32mSSLH ကို ထည့်သွင်းမှာလား \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read resp
			[[ "$resp" = 's' ]] && {
				verif_ptrs 443 || fun_conexao

				fun_instsslh() {
					ptssl="443"
					ptvpn="1194"
					
					DEBIAN_FRONTEND=noninteractive apt-get install -y sslh > /dev/null 2>&1
					
					cat > /etc/default/sslh <<-EOF
						# Default Debian config for SSLH
						RUN=yes
						DAEMON=/usr/sbin/sslh
						DAEMON_OPTS="--user sslh --listen 0.0.0.0:443 --ssh 127.0.0.1:22 --ssl 127.0.0.1:443 --http 127.0.0.1:80 --pidfile /var/run/sslh/sslh.pid"
					EOF
					
					systemctl enable sslh
					systemctl restart sslh
				}
				echo -e "\n\033[1;32mSSLH ကို ထည့်သွင်းနေပါတယ် !\033[0m\n"
				fun_bar 'fun_instsslh'
				echo -e "\n\033[1;32mSSLH ကို စတင်နေပါတယ် !\033[0m\n"
				fun_bar 'systemctl restart sslh'
				
				if ss -tlnp | grep -q 'sslh'; then
					echo -e "\n\033[1;32mအောင်မြင်စွာ ထည့်သွင်းပြီးပါပြီ !\033[0m"
				else
					echo -e "\n\033[1;31mမမျှော်လင့်သော အမှား !\033[0m"
				fi
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mပြန်သွားနေပါတယ်..\033[0m"
				sleep 1
				fun_conexao
			}
		else
			clear
			echo -e "\E[41;1;37m             SSLH ဖယ်ရှားရန်               \E[0m\n"
			echo -ne "\033[1;32mSSLH ကို ဖယ်ရှားမှာလား \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
			read respo
			[[ "$respo" = "s" ]] && {
				fun_delsslh() {
					systemctl stop sslh
					apt-get remove sslh -y > /dev/null 2>&1
					apt-get purge sslh -y > /dev/null 2>&1
					apt-get autoremove -y > /dev/null 2>&1
				}
				echo -e "\n\033[1;32mSSLH ကို ဖယ်ရှားနေပါတယ် !\033[0m\n"
				fun_bar 'fun_delsslh'
				echo -e "\n\033[1;32mအောင်မြင်စွာ ဖယ်ရှားပြီးပါပြီ !\033[0m\n"
				sleep 2
				fun_conexao
			} || {
				echo -e "\n\033[1;31mပြန်သွားနေပါတယ်..\033[0m"
				sleep 1
				fun_conexao
			}
		fi
	}

	# Main connection menu
	fun_conexao() {
		while true; do
			[[ ! -e '/home/sshplus' ]] && exit 0
			clear
			echo -e "\E[44;1;37m                ချိတ်ဆက်မှု နည်းလမ်းများ                 \E[0m\n"
			
			# Check services status
			echo -e "\033[1;32mစနစ်: \033[1;33mOPENSSH \033[1;32mPORT: \033[1;37m$(grep '^Port' /etc/ssh/sshd_config | cut -d' ' -f2 | xargs | head -1)" && sts6="\033[1;32m◉ "
			
			[[ "$(ss -tlpn | grep 'docker' | wc -l)" != '0' ]] && {
				echo -e "\033[1;32mစနစ်: \033[1;33mCHISEL: \033[1;32mPORT: \033[1;37m$(ss -tlnp | grep 'docker' | awk '{print $4}' | cut -d: -f2 | sort -u | head -1)"
				sts8="\033[1;32m◉ "
			} || {
				sts8="\033[1;31m○ "
			}
			
			[[ "$(pgrep -f 'slowdns' | wc -l)" != '0' ]] && sts9="\033[1;32m◉ " || sts9="\033[1;31m○ "
			
			[[ "$(ss -tlpn | grep 'sslh' | wc -l)" != '0' ]] && {
				echo -e "\033[1;32mစနစ်: \033[1;33mSSLH: \033[1;32mPORT: \033[1;37m$(ss -tlnp | grep 'sslh' | awk '{print $4}' | cut -d: -f2 | sort -u | head -1)"
				sts7="\033[1;32m◉ "
			} || {
				sts7="\033[1;31m○ "
			}

			[[ "$(ss -tlpn | grep 'openvpn' | wc -l)" != '0' ]] && {
				echo -e "\033[1;32mစနစ်: \033[1;33mOPENVPN: \033[1;32mPORT: \033[1;37m$(ss -tlnp | grep 'openvpn' | awk '{print $4}' | cut -d: -f2 | sort -u | head -1)"
				sts5="\033[1;32m◉ "
			} || {
				sts5="\033[1;31m○ "
			}

			[[ "$(pgrep -f 'proxy.py\|wsproxy.py' | wc -l)" != '0' ]] && {
				proxy_ports=$(ss -tlnp 2>/dev/null | grep python | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
				[[ -n "$proxy_ports" ]] && echo -e "\033[1;32mစနစ်: \033[1;33mPROXY SOCKS \033[1;32mPORT: \033[1;37m$proxy_ports"
				sts4="\033[1;32m◉ "
			} || {
				sts4="\033[1;31m○ "
			}
			
			[[ -e "/etc/stunnel/stunnel.conf" ]] && {
				ssl_port=$(ss -tlnp | grep stunnel | awk '{print $4}' | cut -d: -f2 | sort -u | head -1)
				echo -e "\033[1;32mစနစ်: \033[1;33mSSL TUNNEL \033[1;32mPORT: \033[1;37m$ssl_port"
				sts3="\033[1;32m◉ "
			} || {
				sts3="\033[1;31m○ "
			}
			
			[[ "$(ss -tlpn | grep 'dropbear' | wc -l)" != '0' ]] && {
				echo -e "\033[1;32mစနစ်: \033[1;33mDROPBEAR \033[1;32mPORT: \033[1;37m$(ss -tlnp | grep 'dropbear' | awk '{print $4}' | cut -d: -f2 | sort -u | head -1)"
				sts2="\033[1;32m◉ "
			} || {
				sts2="\033[1;31m○ "
			}
			
			[[ "$(ss -tlpn | grep 'squid' | wc -l)" != '0' ]] && {
				squid_ports=$(ss -tlnp | grep 'squid' | awk '{print $4}' | cut -d: -f2 | sort -u | xargs)
				echo -e "\033[1;32mစနစ်: \033[1;33mSQUID \033[1;32mPORT: \033[1;37m$squid_ports"
				sts1="\033[1;32m◉ "
			} || {
				sts1="\033[1;31m○ "
			}
			
			echo -e "\033[0;34m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\033[0m"
			echo ""
			echo -e "\033[1;31m[\033[1;36m01\033[1;31m] \033[1;37m• \033[1;33mOPENSSH $sts6\033[1;31m
[\033[1;36m02\033[1;31m] \033[1;37m• \033[1;33mSQUID PROXY $sts1\033[1;31m
[\033[1;36m03\033[1;31m] \033[1;37m• \033[1;33mDROPBEAR $sts2\033[1;31m
[\033[1;36m04\033[1;31m] \033[1;37m• \033[1;33mOPENVPN $sts5\033[1;31m
[\033[1;36m05\033[1;31m] \033[1;37m• \033[1;33mPROXY SOCKS $sts4\033[1;31m
[\033[1;36m06\033[1;31m] \033[1;37m• \033[1;33mSSL TUNNEL $sts3\033[1;31m
[\033[1;36m07\033[1;31m] \033[1;37m• \033[1;33mSSLH MULTIPLEX $sts7\033[1;31m
[\033[1;36m08\033[1;31m] \033[1;37m• \033[1;33mCHISEL $sts8\033[1;31m
[\033[1;36m09\033[1;31m] \033[1;37m• \033[1;33mSLOWDNS $sts9\033[1;31m
[\033[1;36m10\033[1;31m] \033[1;37m• \033[1;33mV2RAY\033[1;31m
[\033[1;36m00\033[1;31m] \033[1;37m• \033[1;33mထွက်မည် \033[1;32m<\033[1;33m<\033[1;31m< \033[0m"
			echo ""
			echo -e "\033[0;34m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\033[0m"
			echo ""
			tput civis
			echo -ne "\033[1;32mဘာလုပ်မလဲ \033[1;33m?\033[1;37m "
			read x
			tput cnorm
			clear
			
			case $x in
			1|01)
				fun_openssh
				;;
			2|02)
				fun_squid
				;;
			3|03)
				fun_drop
				;;
			4|04)
				fun_openvpn
				;;
			5|05)
				fun_socks
				;;
			6|06)
				inst_ssl
				;;
			7|07)
				fun_sslh
				;;
			8|08)
				fun_chisel
				;;
			9|09)
				slow_setup
				;;
			10)
				fun_v2rayins
				;;
			0|00)
				echo -e "\033[1;32mထွက်နေပါတယ်...\033[0m"
				sleep 1
				clear
				exit 0
				;;
			*)
				echo -e "\033[1;31mမှားယွင်းသော ရွေးချယ်မှု !\033[0m"
				sleep 1
				;;
			esac
		done
	}

	# Start main menu
	fun_conexao
}

# Run main function
main
